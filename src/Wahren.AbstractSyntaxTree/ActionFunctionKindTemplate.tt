<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Memory" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.Basic.dll" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.TextTemplateHelper.dll" #>
<#@ import namespace="Wahren.AbstractSyntaxTree" #>
<#@ import namespace="Wahren.AbstractSyntaxTree.TextTemplateHelper" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#nullable enable
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
namespace Wahren.AbstractSyntaxTree;
<# foreach (var (prefix, infos) in new (string, IEnumerable<CallableInfo>)[] {
    ("Function", CallableInfo.FunctionInfoNormals),
    ("Action", CallableInfo.Specials.Concat(CallableInfo.ActionInfoNormals)),
}) { 
int nameMaxLength = 0; int nameMinLength = int.MaxValue; #>

public enum <#= prefix #>Kind : uint
{
<#  foreach (var info in infos) {
        if (nameMaxLength < info.Name.Length) { nameMaxLength = info.Name.Length; }
        if (nameMinLength > info.Name.Length) { nameMinLength = info.Name.Length; } #>
    <#= info.Name.Escape() #>,
<# } #>
    None = uint.MaxValue,
}

public static class <#= prefix #>KindHelper
{
    public static <#= prefix #>Kind Convert(ReadOnlySpan<char> key)
    {
        if (key.Length < <#= nameMinLength #> || key.Length > <#= nameMaxLength #>)
        {
            return <#= prefix #>Kind.None;
        }

        switch (StringHashUtility.Calc(key))
        {
<# foreach (var (hash, infoArray) in infos.GroupBy(x => x.GetHashCode(), x => x, (hash, infoEnumerable) => (hash, infoEnumerable.ToArray()))) { #>
            case 0x<#= hash.ToString("X16") #>UL:
<#  if (infoArray.Length == 1) { var info = infoArray[0]; #>
<#      if (info.Name.Length <= StringHashUtility.HashLengthMax) { #>
                return <#= prefix #>Kind.<#= info.Name.Escape() #>;
<#      } else if (info.Name.Length == StringHashUtility.HashLengthMax + 1) { #>
                if (key.Length != StringHashUtility.HashLengthMax + 1)
                {
                    break;
                }
                switch (key[StringHashUtility.HashLengthMax])
                {
                    case '<#= char.ToUpperInvariant(info.Name[StringHashUtility.HashLengthMax]) #>':
                    case '<#= char.ToLowerInvariant(info.Name[StringHashUtility.HashLengthMax]) #>':
                        return <#= prefix #>Kind.<#= info.Name.Escape() #>;
                }
                break;
<#      } else { #>
                if (StringHashUtility.Calc(key.Slice(StringHashUtility.HashLengthMax)) == 0x<#= StringHashUtility.Calc(info.Name.Substring(StringHashUtility.HashLengthMax)).ToString("X16") #>UL)
                {
                    return <#= prefix #>Kind.<#= info.Name.Escape() #>;
                }
                break;
<#      } #>
<#  } else { #>
                switch (key.Length - StringHashUtility.HashLengthMax)
                {
<#      foreach (var (len, infoArrayInner) in infoArray.GroupBy(x => x.Name.Length, x => x, (len, xs) => (len, xs.ToArray()))) { #>
                    case <#= len - StringHashUtility.HashLengthMax #>:
<#          if (len == StringHashUtility.HashLengthMax) {#>
                        return <#= prefix #>Kind.<#= infoArrayInner[0].Name.Escape() #>;
<#          } else { #>
                        switch (StringHashUtility.Calc(key.Slice(StringHashUtility.HashLengthMax)))
                        {
<#              foreach (var info in infoArrayInner) { #>
                            case 0x<#= StringHashUtility.Calc(info.Name.Substring(StringHashUtility.HashLengthMax)).ToString("X16") #>UL:
                                return <#= prefix #>Kind.<#= info.Name.Escape() #>;
<#              } #>
                        }
<#          } #>
                        break;
<#      } #>
                }
                break;
<#  } #>
<# } #>
        }

        return <#= prefix #>Kind.None;
    }
}
<# } #>