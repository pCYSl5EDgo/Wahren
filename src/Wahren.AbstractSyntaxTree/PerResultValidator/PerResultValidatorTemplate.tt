<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.TextTemplateHelper.dll" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.Basic.dll" #>
<#@ import namespace="Wahren.AbstractSyntaxTree" #>
<#@ import namespace="Wahren.AbstractSyntaxTree.TextTemplateHelper" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
#nullable enable

namespace Wahren.AbstractSyntaxTree.Parser;

public static partial class PerResultValidator
{
	public static void AddReferenceAndValidate(ref Context context, ref Result result)
	{
<# foreach (var nodeInfo in NodeInfo.Nodes) { #>
		foreach (ref var node in result.<#= nodeInfo.Name #>NodeList.AsSpan())
		{
			AddReferenceAndValidate(ref context, ref result, ref node);
		}
<# } #>
	}
<# foreach (var nodeInfo in NodeInfo.Nodes) {
	var elements = nodeInfo.Elements.Where(x => x.ReferenceKind.CanProcessEarly()); #>

	public static void AddReferenceAndValidate(ref Context context, ref Result result, ref <#= nodeInfo.Name #>Node node)
	{
<#  if (nodeInfo.HasBlock) { #>
		foreach (var statement in node.Statements.AsSpan())
		{
			AddReferenceAndValidate(ref context, ref result, statement);
		}
<#  } #>
<#	foreach (var element in elements) {
		switch (element.ReferenceKind) { #>
<#			default: #>
		// Ignore <#= element.ReferenceKind #> <#= nodeInfo.Name #> <#= element.Name #>
<#				break;#>
<#			case ReferenceKind.Scenario					: #>
<#			case ReferenceKind.Event					: #>
<#			case ReferenceKind.Story					: #>
<#			case ReferenceKind.Movetype					: #>
<#			case ReferenceKind.Skill					: #>
<#			case ReferenceKind.Skillset					: #>
<#			case ReferenceKind.Race						: #>
<#			case ReferenceKind.Unit						: #>
<#			case ReferenceKind.Class					: #>
<#			case ReferenceKind.Power					: #>
<#			case ReferenceKind.Spot						: #>
<#			case ReferenceKind.Field					: #>
<#			case ReferenceKind.Object					: #>
<#			case ReferenceKind.Dungeon					: #>
<#			case ReferenceKind.Voice					: #>
<#			case ReferenceKind.AttributeType			: #>
<#			case ReferenceKind.VoiceTypeReader			: #>
<#			case ReferenceKind.VoiceTypeWriter			: #>
<#			case ReferenceKind.FieldAttributeTypeReader	: #>
<#			case ReferenceKind.FieldAttributeTypeWriter	: #>
<#			case ReferenceKind.FieldIdReader			: #>
<#			case ReferenceKind.FieldIdWriter			: #>
<#			case ReferenceKind.ClassTypeReader			: #>
<#			case ReferenceKind.ClassTypeWriter			: #>
<#			case ReferenceKind.SkillGroupReader			: #>
<#			case ReferenceKind.map						: #>
<#			case ReferenceKind.bgm						: #>
<#			case ReferenceKind.imagedata				: #>
<#			case ReferenceKind.face						: #>
<#			case ReferenceKind.sound					: #>
<#			case ReferenceKind.picture					: #>
<#			case ReferenceKind.image_file				: #>
<#			case ReferenceKind.flag						: #>
<#			case ReferenceKind.font						: #>
		AddReference(ref result, ref node.<#= element.Name.Escape() #>, ref result.<#= element.ReferenceKind #>Set, ReferenceKind.<#= element.ReferenceKind #>);
<#				break;#>
<#			case ReferenceKind.Number: #>
<#			case ReferenceKind.Boolean: #>
<#			case ReferenceKind.RedBlue: #>
<#			case ReferenceKind.Status: #>
		Validate<#= element.ReferenceKind #>(ref result, ref node.<#= element.Name.Escape() #>, "<#= nodeInfo.Name #>", "<#= element.Name #>");
<#				break;#>
<#			case ReferenceKind.Skill | ReferenceKind.Boolean: #>
		AddReferenceSkillBoolean(ref result, ref node.<#= element.Name.Escape() #>, "<#= nodeInfo.Name #>", "<#= element.Name #>");
<#				break;#>
<#			case ReferenceKind.Status | ReferenceKind.Number: #>
<#			case ReferenceKind.Boolean | ReferenceKind.Number: #>
		Validate<#= element.ReferenceKind ^ ReferenceKind.Number #>Number(ref result, ref node.<#= element.Name.Escape() #>, "<#= nodeInfo.Name #>", "<#= element.Name #>");
<#				break;#>
<#			case ReferenceKind.Special: #>
<#			case ReferenceKind.Special | ReferenceKind.Number: #>
		SpecialTreatment_<#= nodeInfo.Name.ToLowerInvariant() #>_<#= element.Name #>(ref result, ref node, ref node.<#= element.Name.Escape() #>);
<#				break;#>
<#			case ReferenceKind.Text: #>
		// Ignore Text <#= nodeInfo.Name #> <#= element.Name #>
<#				break;#>
<#		} #>
<#	}#>
	}
<#	foreach (var element in elements) { #>
<#	    if ((element.ReferenceKind & ReferenceKind.Special) == ReferenceKind.Special && element.SpecialStringArray is { Length: > 0 }) { #>

<#          if (element.VariantType == "") { #>
	private static void SpecialTreatment_<#= nodeInfo.Name.ToLowerInvariant() #>_<#= element.Name #>(ref Result result, ref <#= nodeInfo.Name #>Node node, ref <#= element.Type #>? value)
<#          } else { #>
	private static void SpecialTreatment_<#= nodeInfo.Name.ToLowerInvariant() #>_<#= element.Name #>(ref Result result, ref <#= nodeInfo.Name #>Node node, ref VariantPair<<#= element.Type #>> pair)
<#          } #>
	{
		static void Validate(ref Result result, ref Pair_NullableString_NullableInt value)
        {
            var span = result.GetSpan(value.Text);
			value.HasReference = true;
			value.ReferenceKind = ReferenceKind.Special;
            if (span.SequenceEqual("<#= element.SpecialStringArray[0] #>"))
            {
                value.ReferenceId = 0;
            }
<#          for (int speIndex = 1; speIndex < element.SpecialStringArray.Length; ++speIndex) { #>
            else if (span.SequenceEqual("<#= element.SpecialStringArray[speIndex] #>"))
            {
                value.ReferenceId = <#= speIndex #>;
            }
<#          } #>
            else
            {
                value.HasReference = false;
<#          if ((element.ReferenceKind & ReferenceKind.Number) == ReferenceKind.Number) { #>
                if (!value.HasNumber)
                {
                    result.ErrorAdd_UnexpectedElementSpecialValue("<#= nodeInfo.Name #>", "<#= element.Name #>", "<#= element.SpecialStringArray[0] #><# for (int speIndex = 1; speIndex < element.SpecialStringArray.Length; ++speIndex) { #>, <#= element.SpecialStringArray[speIndex] #><# } #>", value.Text);
                }
<#          } else { #>
                result.ErrorAdd_UnexpectedElementSpecialValue("<#= nodeInfo.Name #>", "<#= element.Name #>", "<#= element.SpecialStringArray[0] #><# for (int speIndex = 1; speIndex < element.SpecialStringArray.Length; ++speIndex) { #>, <#= element.SpecialStringArray[speIndex] #><# } #>", value.Text);
<#          } #>
            }
        }

<#          if (element.VariantType == "") { #>
<#             if (element.Type == "Pair_NullableString_NullableIntElement") { #>
        if (value is { HasValue: true })
        {
            Validate(ref result, ref value.Value);
        }
<#              } else { #>
        if (value is { HasValue: true, Value.Count: > 0 })
        {
            foreach (ref var v in value.Value.AsSpan())
            {
                Validate(ref result, ref v);
            }
        }
<#              } #>
<#          } else { #>
<#             if (element.Type == "Pair_NullableString_NullableIntElement") { #>
        if (pair.Value is { HasValue: true, Value.HasText: true })
        {
            Validate(ref result, ref pair.Value.Value);
        }

        if (pair.VariantArray is not null)
        {
            foreach (var item in pair.VariantArray)
            {
                if (item is { HasValue: true, Value.HasText: true })
                {
                    Validate(ref result, ref item.Value);
                }
            }
        }
<#              } else { #>
        if (pair.Value is { HasValue: true, Value.Count: > 0 })
        {
            foreach (ref var value in pair.Value.Value.AsSpan())
            {
                Validate(ref result, ref value);
            }
        }

        if (pair.VariantArray is not null)
        {
            foreach (var item in pair.VariantArray)
            {
                if (item is { HasValue: true, Value.Count: > 0 })
                {
                    foreach (ref var value in item.Value.AsSpan())
                    {
                        Validate(ref result, ref value);
                    }
                }
            }
        }
<#              } #>
<#	        } #>
	}
<#	    } #>
<#  } #>
<# } #>
}
