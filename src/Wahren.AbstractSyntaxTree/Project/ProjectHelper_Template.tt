<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.TextTemplateHelper.dll" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.Basic.dll" #>
<#@ import namespace="Wahren" #>
<#@ import namespace="Wahren.AbstractSyntaxTree" #>
<#@ import namespace="Wahren.AbstractSyntaxTree.TextTemplateHelper" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# #nullable enable #>
#nullable enable
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using Wahren.AbstractSyntaxTree.Parser;

namespace Wahren.AbstractSyntaxTree.Project;

public sealed partial class Project
{
<# foreach (var node in NodeInfo.Nodes) { #>
<#	if (node.IsDetail5 || node.IsSkillOrSkillset) { continue; } #>
	public StringSpanKeyTrackableSet<AmbiguousNameReference>.Single AmbiguousDictionary_<#= node.Name #> = default;
<# } #>

    public void Dispose()
    {
        Files.Dispose();
        FileAnalysisList.Dispose();
        ErrorBag.Clear();

        AmbiguousDictionary_SkillSkillset.Dispose();
        AmbiguousDictionary_UnitClassPowerSpotRace.Dispose();
<# foreach (var node in NodeInfo.Nodes) { #>
<#	if (node.IsDetail5 || node.IsSkillOrSkillset) { continue; } #>
    	AmbiguousDictionary_<#= node.Name #>.Dispose();
<# } #>
    }

    public void AddReferenceAndValidate()
    {
        var fileSpan = Files.AsSpan();
        StringSpanKeyTrackableSet<AmbiguousNameReference> ambiguousDictionary_UnitClassPowerSpotRace = new();
        StringSpanKeyTrackableSet<AmbiguousNameReference> ambiguousDictionary_SkillSkillset = new();
<# foreach (var node in NodeInfo.Nodes) { #>
<#	if (node.IsDetail5 || node.IsSkillOrSkillset) { continue; } #>
    	StringSpanKeyTrackableSet<AmbiguousNameReference> ambiguousDictionary_<#= node.Name #> = new();
<# } #>
        try
        {
            var noDuplication = true;
            for (int fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
            {
                ref var file = ref fileSpan[fileIndex];
<# foreach (var node in NodeInfo.Nodes) { #>

                var span_<#= node.Name #> = file.<#= node.Name #>NodeList.AsSpan();
                for (int i = 0; i < span_<#= node.Name #>.Length; ++i)
                {
                    ref var node = ref span_<#= node.Name #>[i];
<#	if (node.IsDetail5) { #>
                    noDuplication &= ambiguousDictionary_UnitClassPowerSpotRace.TryRegisterTrack(file.GetSpan(node.Name), new(fileIndex, i, ReferenceKind.<#= node.Name #>, node.Name));
<#  } else if (node.IsSkillOrSkillset) { #>
                    noDuplication &= ambiguousDictionary_SkillSkillset.TryRegisterTrack(file.GetSpan(node.Name), new(fileIndex, i, ReferenceKind.<#= node.Name #>, node.Name));
<#  } else { #>
                    noDuplication &= ambiguousDictionary_<#= node.Name #>.TryRegisterTrack(file.GetSpan(node.Name), new(fileIndex, i, ReferenceKind.<#= node.Name #>, node.Name));
<#  } #>
                }
<# } #>
            }

            if (noDuplication)
            {
                AmbiguousDictionary_UnitClassPowerSpotRace = ambiguousDictionary_UnitClassPowerSpotRace.ToSingle();
                AmbiguousDictionary_SkillSkillset = ambiguousDictionary_SkillSkillset.ToSingle();
<# foreach (var node in NodeInfo.Nodes) { #>
<#	if (node.IsDetail5 || node.IsSkillOrSkillset) { continue; } #>
    	        AmbiguousDictionary_<#= node.Name #> = ambiguousDictionary_<#= node.Name #>.ToSingle();
<# } #>
            }
            else
            {
                PerResultValidator.CollectError(fileSpan, ErrorBag, ref ambiguousDictionary_UnitClassPowerSpotRace);
                PerResultValidator.CollectError(fileSpan, ErrorBag, ref ambiguousDictionary_SkillSkillset);
<# foreach (var node in NodeInfo.Nodes) { #>
<#	if (node.IsDetail5 || node.IsSkillOrSkillset) { continue; } #>
    	        PerResultValidator.CollectError(fileSpan, ErrorBag, ref ambiguousDictionary_<#= node.Name #>);
<# } #>
            }
        }
        finally
        {
            ambiguousDictionary_UnitClassPowerSpotRace.Dispose();
            ambiguousDictionary_SkillSkillset.Dispose();
<# foreach (var node in NodeInfo.Nodes) { #>
<#	if (node.IsDetail5 || node.IsSkillOrSkillset) { continue; } #>
    	    ambiguousDictionary_<#= node.Name #>.Dispose();
<# } #>
        }

        for (int fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[fileIndex];
            var analysisResult = FileAnalysisList[fileIndex];
<# foreach (var node in NodeInfo.Nodes) { #>
            foreach (ref var node in file.<#= node.Name #>NodeList.AsSpan())
            {
                AddReferenceAndValidate(ref file, analysisResult, ref node);
            }
<# } #>
        }
    }
}
