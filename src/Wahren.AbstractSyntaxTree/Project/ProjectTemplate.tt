<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.TextTemplateHelper.dll" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.Basic.dll" #>
<#@ import namespace="Wahren" #>
<#@ import namespace="Wahren.AbstractSyntaxTree" #>
<#@ import namespace="Wahren.AbstractSyntaxTree.TextTemplateHelper" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#nullable enable
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>

namespace Wahren.AbstractSyntaxTree.Project;

using Parser;
using Statement;
using Statement.Expression;
<#
var readerwriters = new string[]{
"Reader",
"Writer",
};
var readwrites = new string[]{
"NumberVariable",
"StringVariable",
"GlobalVariable",
"GlobalStringVariable",
"ClassType",
"VoiceType",
"FieldId",
"FieldAttributeType",
};
#>

public sealed partial class Project
{<# foreach (var node in NodeInfo.Nodes) {  #>

	public ref Result TryGet<#= node.Name #>Node(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        ref var pair = ref <#= node.Name #>.TryGetTrack(name, queryFileId);
        if (!Unsafe.IsNullRef(ref pair))
        {
            index = pair.Id;
            return ref Files[pair.FileId];
        }
<#  if (node.IsDetail5 || node.IsSkillOrSkillset) { #>
        ref var track = ref AmbiguousDictionary_<#= node.IsDetail5 ? "UnitClassPowerSpotRace" : "SkillSkillset" #>.TryGet(name);
        if (!Unsafe.IsNullRef(ref track) && track.Kind == ReferenceKind.<#= node.Name #>)
        {
            index = (uint)track.NodeIndex;
            return ref Files[track.ResultId];
        }
<#  } else { #>
        var files = Files.AsSpan();
        for (int i = 0; i < files.Length; ++i)
        {
            ref var file = ref files[i];
            ref var list = ref file.<#= node.Name #>NodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    <#= node.Name #>.TryRegisterTrack(name, ((uint)i, index), queryFileId);
                    return ref file;
                }
            }
        }
<#  } #>

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

    public ref Result TryGet<#= node.Name #>Node(ReadOnlySpan<char> name, out uint index)
    {
        ref var pair = ref <#= node.Name #>.TryGet(name, out _);
        if (!Unsafe.IsNullRef(ref pair))
        {
            index = pair.Id;
            return ref Files[pair.FileId];
        }
<#  if (node.IsDetail5 || node.IsSkillOrSkillset) { #>
        ref var track = ref AmbiguousDictionary_<#= node.IsDetail5 ? "UnitClassPowerSpotRace" : "SkillSkillset" #>.TryGet(name);
        if (!Unsafe.IsNullRef(ref track) && track.Kind == ReferenceKind.<#= node.Name #>)
        {
            index = (uint)track.NodeIndex;
            return ref Files[track.ResultId];
        }
<#  } else { #>
        var files = Files.AsSpan();
        for (int i = 0; i < files.Length; ++i)
        {
            ref var file = ref files[i];
            ref var list = ref file.<#= node.Name #>NodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    return ref file;
                }
            }
        }
<#  } #>

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }
<# } #>

    public bool CheckExistance()
    {
        var fileSpan = Files.AsSpan();
        var success = true;
<# foreach (var node in NodeInfo.Nodes) { #>
<#  var offset = 0;
    switch (node.Name){
        case "Scenario":
            offset = 10;
            break;
        case "Unit":
            offset = 2;
            break;
    }#>

        for (uint fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[(int)fileIndex];
            ref var set = ref file.<#= node.Name #>Set;
            for (uint i = <#= offset #>, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGet<#= node.Name #>Node(fileIndex, name, out _)))
                {
                    continue;
                }

                success = false;
                this.ErrorAdd_NameStructureNotFound("<#= node.Name.ToLowerInvariant() #>", name, ref file, set.References[i].AsSpan());
            }
        }
<# } #>
<# foreach (var name in readwrites) { #>

        for (int fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[fileIndex];
            ref var set = ref file.<#= name #>ReaderSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                bool notFound = !file.<#= name #>WriterSet.TryGet(name, out _);
                if (notFound)
                {
                    for (int anotherFileIndex = 0; anotherFileIndex < fileSpan.Length; ++anotherFileIndex)
                    {
                        if (anotherFileIndex == fileIndex)
                        {
                            continue;
                        }

                        if (fileSpan[anotherFileIndex].<#= name #>WriterSet.TryGet(name, out _))
                        {
                            notFound = false;
                            break;
                        }
                    }
                }

                if (notFound)
                {
                    this.ErrorAdd_CorrespondingWritingNotFound("<#= name #>", name, ref file, set.References[i].AsSpan());
                }
            }
        }
<# } #>

        for (uint fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[(int)fileIndex];
            ref var set = ref file.AttributeTypeSet;
            for (uint i = <#= Enum.GetNames(typeof(AttributeTypeKind)).Length #>, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (ContainsAttributeType(name))
                {
                    continue;
                }

                success = false;
                this.ErrorAdd_AttributeTypeNotFound(name, ref file, set.References[i].AsSpan());
            }
        }

        return success;
    }
<# foreach (var (func, expres, infos) in new (string, string, CallableInfo[])[] { ("Function", "Expression", CallableInfo.FunctionInfoNormals), ("Action", "Statement", CallableInfo.ActionInfoNormals) }) { #>

    private void AddReferenceAndValidate_Call(ref Result result, Call<#= func #><#= expres #> call)
    {
        var arguments = call.Arguments.AsSpan();
        if (arguments.IsEmpty)
        {
            return;
        }

        ref var argument = ref arguments[0];
        ReadOnlySpan<char> span;
        switch (call.Kind)
        {
<#  foreach (((int min, int max), IEnumerable<(string, ReferenceKind[][])> groupEnumerable) in infos.GroupBy(
        item => (item.Min, item.Max),
        item => (item.Name, item.KindArray),
        (key, values) => (key, values)
    )
) { #>
<#      if (min == max && min == 0) { continue; } #>
<#      if (min == 0 && max == int.MaxValue) { #>
<#          foreach ((string name, ReferenceKind[][] arrayArray) in groupEnumerable) { #>
            case <#= func #>Kind.<#= name.Escape() #>:
                result.ErrorAdd($"Unknown action '<#= name #>'.", call.TokenId);
                break;
<#          } #>
<#          continue; #>
<#      } #>
<#      foreach ((string name, ReferenceKind[][] arrayArray) in groupEnumerable.Where(x => !x.Item2.CanProcessEarly())) { #>
            case <#= func #>Kind.<#= name.Escape() #>:
<#          ReferenceKind[] array; #>
<#          if (arrayArray.Length == 0) { #>
                // skip <#= name #>
                break;
<#              continue; #>
<#          } #>
<#          if (arrayArray.Length > 1) { #>
                switch (arguments.Length)
                {
<#              for (int j = min; j <= max; ++j) { #>
<#                  array = arrayArray[j - min]; #>
                    case <#= j #>:
<#                  for (int i = 0; i < j; ++i) { #>
<#                      var reference = array[i]; #>
                        <#= reference.ProcessLate(i, name, 6) #>
<#                  } #>
                        break;
<#              } #>
                }
                break;
<#              continue; #>
<#          } #>
<#          array = arrayArray[0]; #>
<#          if (array.Length == 0) { #>
                // ERROR
<#          } else if (min == max) { #>
<#              for (int i = 0; i < array.Length; ++i) { var reference = array[i]; #>
                <#= reference.ProcessLate(i, name, 4) #>
<#              } #>
<#          } else { #>
<#              if (array.Length == min) { #>
<#                  for (int i = 0; i < array.Length; ++i) { ReferenceKind reference = array[i]; #>
                <#= reference.ProcessLate(i, name, 4) #>
<#                  } #>
                for (int i = <#= array.Length #>; i < arguments.Length; ++i)
                {
                    <#= array[array.Length - 1].ProcessLate(-1, name, 5) #>
                }
<#              } else if (array.Length == max) { #>
<#                  for (int i = 0; i < min; ++i) { ReferenceKind reference = array[i]; #>
                <#= reference.ProcessLate(i, name, 4) #>
<#                  } #>
<#                  for (int i = min; i < array.Length; ++i) { ReferenceKind reference = array[i]; #>
                if (arguments.Length <= <#= i #>)
                {
                    break;
                }
                <#= reference.ProcessLate(i, name, 4) #>
<#                  } #>
<#              } else { #>
<#                  for (int i = 0; i < min; ++i) { ReferenceKind reference = array[i]; #>
                <#= reference.ProcessLate(i, name, 4) #>
<#                  } #>
<#                  for (int i = min; i < array.Length; ++i) { ReferenceKind reference = array[i]; #>
                if (arguments.Length <= <#= i #>)
                {
                    break;
                }
                <#= reference.ProcessLate(i, name, 4) #>
<#                  } #>
                for (int i = <#= array.Length #>; i < arguments.Length; ++i)
                {
                    <#= array[array.Length - 1].ProcessLate(-1, name, 5) #>
                }
<#              }#>
<#          } #>
                break;
<#      } #>
<#  } #>
        }
    }
<# } #>
<# foreach (var node in NodeInfo.Nodes) { #>
<#	var elements = node.Elements.Where(x => !x.ReferenceKind.CanProcessEarly()).ToArray(); #>

    private void AddReferenceAndValidate(ref Result result, ref <#= node.Name #>Node node)
    {
<#  if (node.HasBlock) { #>
        foreach (var statement in node.Statements.AsSpan())
		{
            if (statement is not null)
            {
			    AddReferenceAndValidate_Statement(ref result, statement);
            }
		}
<#  } #>
<#	for (int elementIndex = 0; elementIndex < elements.Length ; ++elementIndex) { #>
<#      ref var element = ref elements[elementIndex]; #>
<#      bool isArray = element.Type == "Pair_NullableString_NullableInt_ArrayElement"; #>
<#      if (element.VariantType == "") { #>
<#          if (isArray) { #>
        if (node.<#= element.CSharpableName #> is { HasValue: true, Value.Count: > 0 })
        {
            foreach (ref var value in node.<#= element.CSharpableName #>.Value.AsSpan())
            {
                SpecialTreatment_<#= node.Name.ToLowerInvariant() #>_<#= element.CSharpableName #>(ref result, ref node, ref value);
            }
        }
<#          } else { #>
        if (node.<#= element.CSharpableName #> is { HasValue: true })
        {
            SpecialTreatment_<#= node.Name.ToLowerInvariant() #>_<#= element.CSharpableName #>(ref result, ref node, ref node.<#= element.CSharpableName #>.Value);
        }
<#          } #>
<#      } else { #>
<#          if (isArray) { #>
        if (node.<#= element.CSharpableName #>.Value is { HasValue: true, Value.Count: > 0 })
        {
            foreach (ref var value in node.<#= element.CSharpableName #>.Value.Value.AsSpan())
            {
                SpecialTreatment_<#= node.Name.ToLowerInvariant() #>_<#= element.CSharpableName #>(ref result, ref node, ref value);
            }
        }
<#          } else { #>
        if (node.<#= element.CSharpableName #>.Value is { HasValue: true })
        {
            SpecialTreatment_<#= node.Name.ToLowerInvariant() #>_<#= element.CSharpableName #>(ref result, ref node, ref node.<#= element.CSharpableName #>.Value.Value);
        }
<#          } #>
        if (node.<#= element.CSharpableName #>.VariantArray is { Length: > 0 })
        {
            foreach (var element in node.<#= element.CSharpableName #>.VariantArray)
            {
<#          if (isArray) { #>
                if (element is not { HasValue: true, Value.Count: > 0 })
                {
                    continue;
                }
                foreach (ref var value in element.Value.AsSpan())
                {
                    SpecialTreatment_<#= node.Name.ToLowerInvariant() #>_<#= element.CSharpableName #>(ref result, ref node, ref value);
                }
<#          } else { #>
                if (element is not { HasValue: true })
                {
                    continue;
                }
                SpecialTreatment_<#= node.Name.ToLowerInvariant() #>_<#= element.CSharpableName #>(ref result, ref node, ref element.Value);
<#          } #>
            }
        }
<#      } #>
<#  } #>
    }
<# } #>
<# foreach (var node in NodeInfo.Nodes) { #>
<#	var elements = node.Elements.Where(x => !x.ReferenceKind.CanProcessEarly()).ToArray(); #>
<#	for (int elementIndex = 0; elementIndex < elements.Length ; ++elementIndex) { #>
<#      ref var element = ref elements[elementIndex]; #>
<#      if (element.ReferenceKind == ReferenceKind.SpecialLate) continue; #>

    private void SpecialTreatment_<#= node.Name.ToLowerInvariant() #>_<#= element.CSharpableName #>(ref Result result, ref <#= node.Name #>Node node, ref Pair_NullableString_NullableInt value)
    {
        <#= ReferenceKindHelper.ProcessElementLate(node.Name, ref element, 2) #>
    }
<#  } #>
<# } #>
}
