<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.TextTemplateHelper.dll" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.Basic.dll" #>
<#@ import namespace="Wahren" #>
<#@ import namespace="Wahren.AbstractSyntaxTree" #>
<#@ import namespace="Wahren.AbstractSyntaxTree.TextTemplateHelper" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#nullable enable
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>

namespace Wahren.AbstractSyntaxTree.Project;

using Parser;
using Statement;
using Statement.Expression;
<#
var types = new string[]{
"Scenario",
"Event",
"Story",
"Movetype",
"Skill",
"Skillset",
"Race",
"Unit",
"Class",
"Power",
"Spot",
"Field",
"Object",
"Dungeon",
"Voice",
};
var readerwriters = new string[]{
"Reader",
"Writer",
};
var readwrites = new string[]{
"NumberVariable",
"StringVariable",
"GlobalVariable",
"GlobalStringVariable",
"ClassType",
"VoiceType",
"FieldId",
"FieldAttributeType",
};
#>

public sealed partial class Project
{<# foreach (var name in types) {  #>

	public ref Result TryGet<#= name #>Node(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        ref var pair = ref <#= name #>.TryGetTrack(name, queryFileId);
        if (!Unsafe.IsNullRef(ref pair))
        {
            index = pair.Id;
            return ref Files[pair.FileId];
        }
<# var is5 = name == "Unit" || name == "Class" || name == "Race" || name == "Spot" || name == "Power"; var is2 = name == "Skill" || name == "Skillset"; #>
<# if (is5 || is2) { #>
        ref var track = ref AmbiguousDictionary_<#= is5 ? "UnitClassPowerSpotRace" : "SkillSkillset" #>.TryGet(name);
        if (!Unsafe.IsNullRef(ref track) && track.Kind == ReferenceKind.<#= name #>)
        {
            index = (uint)track.NodeIndex;
            return ref Files[track.ResultId];
        }
<# } else { #>
        var files = Files.AsSpan();
        for (int i = 0; i < files.Length; ++i)
        {
            ref var file = ref files[i];
            ref var list = ref file.<#= name #>NodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    <#= name #>.TryRegisterTrack(name, ((uint)i, index), queryFileId);
                    return ref file;
                }
            }
        }
<# } #>

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }
<# } #>

    public bool CheckExistance()
    {
        System.Text.StringBuilder? builder = null;
        var fileSpan = Files.AsSpan();
        var success = true;
<# foreach (var name in types) { #>
<#  var offset = 0;
    switch (name){
        case "Scenario":
            offset = 10;
            break;
    }#>

        for (uint fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[(int)fileIndex];
            ref var set = ref file.<#= name #>Set;
            for (uint i = <#= offset #>, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGet<#= name #>Node(fileIndex, name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"<#= name.ToLowerInvariant() #> '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }
<# } #>
<# foreach (var name in readwrites) { #>

        for (int fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[fileIndex];
            ref var set = ref file.<#= name #>ReaderSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                bool notFound = !file.<#= name #>WriterSet.TryGet(name, out _);
                if (notFound)
                {
                    for (int anotherFileIndex = 0; anotherFileIndex < fileSpan.Length; ++anotherFileIndex)
                    {
                        if (anotherFileIndex == fileIndex)
                        {
                            continue;
                        }

                        if (fileSpan[anotherFileIndex].<#= name #>WriterSet.TryGet(name, out _))
                        {
                            notFound = false;
                            break;
                        }
                    }
                }

                if (notFound)
                {
                    builder ??= new();
                    builder.Clear();
                    builder.Append($"Corresponding writing to the '{name}' is not found in this solution.");
                    foreach (var tokenId in set.References[i].AsSpan())
                    {
                        ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                        builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                    }
                    SolutionErrorList.Add(new(builder.ToString()));
                }
            }
        }
<# } #>

        for (uint fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[(int)fileIndex];
            ref var set = ref file.AttributeTypeSet;
            for (uint i = <#= Enum.GetNames(typeof(AttributeTypeKind)).Length #>, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (ContainsAttributeType(name))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"attribute type '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        return success;
    }
<# foreach (var (func, expres, infos) in new (string, string, CallableInfo[])[] { ("Function", "Expression", CallableInfo.FunctionInfoNormals), ("Action", "Statement", CallableInfo.ActionInfoNormals) }) { #>

    private void AddReferenceAndValidate(ref Result result, Call<#= func #><#= expres #> call)
    {
        var arguments = call.Arguments.AsSpan();
        if (arguments.IsEmpty)
        {
            return;
        }

        ref var argument = ref arguments[0];
        ReadOnlySpan<char> span;
        switch (call.Kind)
        {
<#  foreach (((int min, int max), IEnumerable<(string, ReferenceKind[][])> groupEnumerable) in infos.GroupBy(
        item => (item.Min, item.Max),
        item => (item.Name, item.KindArray),
        (key, values) => (key, values)
    )
) { #>
<#      if (min == max && min == 0) { continue; } #>
<#      if (min == 0 && max == int.MaxValue) { #>
<#          foreach ((string name, ReferenceKind[][] arrayArray) in groupEnumerable) { #>
            case <#= func #>Kind.<#= name.Escape() #>:
                result.ErrorList.Add(new($"Unknown action '<#= name #>'.", result.TokenList[call.TokenId].Range));
                break;
<#          } #>
<#          continue; #>
<#      } #>
<#      foreach ((string name, ReferenceKind[][] arrayArray) in groupEnumerable.Where(x => !x.Item2.CanProcessEarly())) { #>
            case <#= func #>Kind.<#= name.Escape() #>:
<#          ReferenceKind[] array; #>
<#          if (arrayArray.Length == 0) { #>
                // skip <#= name #>
                break;
<#              continue; #>
<#          } #>
<#          if (arrayArray.Length > 1) { #>
                switch (arguments.Length)
                {
<#              for (int j = min; j <= max; ++j) { #>
<#                  array = arrayArray[j - min]; #>
                    case <#= j #>:
<#                  for (int i = 0; i < j; ++i) { #>
<#                      var reference = array[i]; #>
                        <#= reference.ProcessLate(i, name, 6) #>
<#                  } #>
                        break;
<#              } #>
                }
                break;
<#              continue; #>
<#          } #>
<#          array = arrayArray[0]; #>
<#          if (array.Length == 0) { #>
                // ERROR
<#          } else if (min == max) { #>
<#              for (int i = 0; i < array.Length; ++i) { var reference = array[i]; #>
                <#= reference.ProcessLate(i, name, 4) #>
<#              } #>
<#          } else { #>
<#              if (array.Length == min) { #>
<#                  for (int i = 0; i < array.Length; ++i) { ReferenceKind reference = array[i]; #>
                <#= reference.ProcessLate(i, name, 4) #>
<#                  } #>
                for (int i = <#= array.Length #>; i < arguments.Length; ++i)
                {
                    <#= array[array.Length - 1].ProcessLate(-1, name, 5) #>
                }
<#              } else if (array.Length == max) { #>
<#                  for (int i = 0; i < min; ++i) { ReferenceKind reference = array[i]; #>
                <#= reference.ProcessLate(i, name, 4) #>
<#                  } #>
<#                  for (int i = min; i < array.Length; ++i) { ReferenceKind reference = array[i]; #>
                if (arguments.Length <= <#= i #>)
                {
                    break;
                }
                <#= reference.ProcessLate(i, name, 4) #>
<#                  } #>
<#              } else { #>
<#                  for (int i = 0; i < min; ++i) { ReferenceKind reference = array[i]; #>
                <#= reference.ProcessLate(i, name, 4) #>
<#                  } #>
<#                  for (int i = min; i < array.Length; ++i) { ReferenceKind reference = array[i]; #>
                if (arguments.Length <= <#= i #>)
                {
                    break;
                }
                <#= reference.ProcessLate(i, name, 4) #>
<#                  } #>
                for (int i = <#= array.Length #>; i < arguments.Length; ++i)
                {
                    <#= array[array.Length - 1].ProcessLate(-1, name, 5) #>
                }
<#              }#>
<#          } #>
                break;
<#      } #>
<#  } #>
        }
    }
<# } #>
<# foreach (var nodeKind in Helper.BlockContainers.Concat(Helper.Inheritables)) { #>
<#	var elements = ElementInfo.Get(nodeKind).Where(x => !x.referenceKind.CanProcessEarly()).ToArray(); #>

    private void AddReferenceAndValidate(ref Result result, ref <#= nodeKind #>Node node)
    {
<#  if (nodeKind.IsBlockContainer()) { #>
        foreach (var statement in node.Statements.AsSpan())
		{
            if (statement is not null)
            {
			    AddReferenceAndValidate(ref result, statement);
            }
		}
<#  } #>
<#	for (int elementIndex = 0; elementIndex < elements.Length ; ++elementIndex) { #>
<#      ref var element = ref elements[elementIndex]; #>
<#      bool isArray = element.name.GetCorrespondingType() == "Pair_NullableString_NullableInt_ArrayElement" || element.name.GetCorrespondingType() == "StringArrayElement"; #>
        if (node.<#= element.Name #>.Value is { HasValue: true })
        {
<#      if (isArray) { #>
            foreach (ref var value in node.<#= element.Name #>.Value.Value.AsSpan())
            {
<#          if (element.referenceKind == ReferenceKind.SpecialLate) { #>
                AddReferenceAndValidateLate_<#= nodeKind #>_<#= element.Name #>(ref result, ref value);
<#          } else { #>
                // <#= element.name.GetCorrespondingType() #>
                <#= ReferenceKindHelper.ProcessElementLate(nodeKind, ref element, 4) #>
<#          }#>
            }
<#      } else { #>
            ref var value = ref node.Value.Value;
<#          if (element.referenceKind == ReferenceKind.SpecialLate) { #>
            AddReferenceAndValidateLate_<#= nodeKind #>_<#= element.Name #>(ref result, ref value);
<#          } else { #>
            // <#= element.name.GetCorrespondingType() #>
            <#= ReferenceKindHelper.ProcessElementLate(nodeKind, ref element, 3) #>
<#          }#>
<#      } #>
        }
        if (node.<#= element.Name #>.VariantArray is { Length: > 0 })
        {
            foreach (var element in node.<#= element.Name #>.VariantArray)
            {
                if (element is not { HasValue: true })
                {
                    continue;
                }
<#      if (isArray) { #>
                foreach (ref var value in element.Value.AsSpan())
                {
<#          if (element.referenceKind == ReferenceKind.SpecialLate) { #>
                    AddReferenceAndValidateLate_<#= nodeKind #>_<#= element.Name #>(ref result, ref value);
<#          } else { #>
                    // <#= element.name.GetCorrespondingType() #>
                    <#= ReferenceKindHelper.ProcessElementLate(nodeKind, ref element, 5) #>
<#          }#>
                }
<#      } else { #>
                ref var value = ref element.Value;
<#          if (element.referenceKind == ReferenceKind.SpecialLate) { #>
                AddReferenceAndValidateLate_<#= nodeKind #>_<#= element.Name #>(ref result, ref value);
<#          } else { #>
                // <#= element.name.GetCorrespondingType() #>
                <#= ReferenceKindHelper.ProcessElementLate(nodeKind, ref element, 4) #>
<#          }#>
<#      } #>
            }
        }
<#  } #>
    }
<# } #>
}
