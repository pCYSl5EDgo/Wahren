<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.TextTemplateHelper.dll" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.Basic.dll" #>
<#@ import namespace="Wahren" #>
<#@ import namespace="Wahren.AbstractSyntaxTree" #>
<#@ import namespace="Wahren.AbstractSyntaxTree.TextTemplateHelper" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# #nullable enable #>
#nullable enable
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using Wahren.AbstractSyntaxTree.Parser;

namespace Wahren.AbstractSyntaxTree.Project;

public sealed partial class Project
{
<# foreach (var node in NodeInfo.Nodes) { #>
<#	var elements = node.Elements;#>
<#	for (nint elementIndex = 0; elementIndex < elements.Length; ++elementIndex) { #>
<#		ref var element = ref elements[elementIndex]; #>

	public <#= element.Type #>? GetRecursive_<#= element.Name #>(ref Result result, ref <#= node.Name #>Node node)
	{
		do
		{
<#		if (element.VariantType == "") { #>
			if (node.<#= element.Name.Escape() #> is not null)
			{
				return node.<#= element.Name.Escape() #>;
			}
<#		} else { #>
			if (node.<#= element.Name.Escape() #>.Value is not null)
			{
				return node.<#= element.Name.Escape() #>.Value;
			}
<#		} #>
			

			if (!node.HasSuper)
			{
				return null;
			}

			var superSpan = result.GetSpan(node.Super);
<#		if (node.IsDetail5) { #>
			ref var track = ref AmbiguousDictionary_UnitClassPowerSpotRace.TryGet(superSpan);
<#		} else if (node.IsSkillOrSkillset) { #>
			ref var track = ref AmbiguousDictionary_SkillSkillset.TryGet(superSpan);
<#		} else { #>
			ref var track = ref AmbiguousDictionary_<#= node.Name #>.TryGet(superSpan);
<#		} #>
			result = ref Files[track.ResultId];
			node = ref result.<#= node.Name #>NodeList[track.NodeIndex];
		} while (true);
	}
<#	} #>
<# } #>
}
