<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.TextTemplateHelper.dll" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.Basic.dll" #>
<#@ import namespace="Wahren.AbstractSyntaxTree" #>
<#@ import namespace="Wahren.AbstractSyntaxTree.TextTemplateHelper" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#nullable enable
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
namespace Wahren.AbstractSyntaxTree.Parser;
<#
var array = new string[]{
"Scenario",
"Event",
"Story",
"Movetype",
"Skill",
"Skillset",
"Race",
"Unit",
"Class",
"Power",
"Spot",
"Field",
"Object",
"Dungeon",
"Voice",
};
#>

public sealed partial class Solution : ISolutionResolver
{<# foreach (var name in array) { #>

	public ref Result TryGet<#= name #>Node(ReadOnlySpan<char> name, out uint index)
    {
        foreach (ref var file in Files)
        {
            ref var list = ref file.<#= name #>NodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }
<# } #>

    public bool CheckExistance()
    {
        var success = true;
        System.Text.StringBuilder? builder = null;
<# foreach (var name in array) { #>

        foreach (ref var file in Files)
        {
            ref var set = ref file.<#= name #>Set;
            for (uint i = <#= name == "Scenario" ? 10 : 0 #>, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGet<#= name #>Node(name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"<#= name.ToLowerInvariant() #> '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }
<# } #>

        foreach (ref var file in Files)
        {
            ref var set = ref file.AttributeTypeSet;
            for (uint i = <#= Enum.GetNames(typeof(AttributeTypeKind)).Length #>, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (ContainsAttributeType(name))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"attribute type '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        return success;
    }
}
