<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.TextTemplateHelper.dll" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.Basic.dll" #>
<#@ import namespace="Wahren" #>
<#@ import namespace="Wahren.AbstractSyntaxTree" #>
<#@ import namespace="Wahren.AbstractSyntaxTree.TextTemplateHelper" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#nullable enable
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
namespace Wahren.AbstractSyntaxTree.Parser;
<#
var array = new string[]{
"Scenario",
"Event",
"Story",
"Movetype",
"Skill",
"Skillset",
"Race",
"Unit",
"Class",
"Power",
"Spot",
"Field",
"Object",
"Dungeon",
"Voice",
};
#>

public interface ISolutionResolver
{<# foreach (var name in array) { #>
    ref Result TryGet<#= name #>Node(uint queryFileId, ReadOnlySpan<char> name, out uint index);
<# } #>

    ref Result TryResolveDetail(uint queryFileId, ReadOnlySpan<char> name, out ReferenceKind kind, out uint index);
    ref Result TryResolveUnitOrClass(uint queryFileId, ReadOnlySpan<char> name, out ReferenceKind kind, out uint index);
    ref Result TryResolveSkillOrSkillset(uint queryFileId, ReadOnlySpan<char> name, out ReferenceKind kind, out uint index);
}

public sealed class FailResolver : ISolutionResolver
{
    public static readonly FailResolver Default = new();
<# foreach (var name in array) { #>
    public ref Result TryGet<#= name #>Node(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        index = 0;
        return ref Unsafe.NullRef<Result>();
    }
<# } #>

    public ref Result TryResolveDetail(uint queryFileId, ReadOnlySpan<char> name, out ReferenceKind kind, out uint index)
    {
        kind = ReferenceKind.Spot; index = 0; return ref Unsafe.NullRef<Result>();
    }

    public ref Result TryResolveUnitOrClass(uint queryFileId, ReadOnlySpan<char> name, out ReferenceKind kind, out uint index)
    {
        kind = ReferenceKind.Unit; index = 0; return ref Unsafe.NullRef<Result>();
    }

    public ref Result TryResolveSkillOrSkillset(uint queryFileId, ReadOnlySpan<char> name, out ReferenceKind kind, out uint index)
    {
        kind = ReferenceKind.Skill; index = 0; return ref Unsafe.NullRef<Result>();
    }
}

public sealed partial class Solution : ISolutionResolver
{<# foreach (var name in array) { #>

	public ref Result TryGet<#= name #>Node(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        ref var pair = ref <#= name #>.TryGetTrack(name, queryFileId);
        if (!Unsafe.IsNullRef(ref pair))
        {
            index = pair.Id;
            return ref Files[pair.FileId];
        }
        
        var files = Files.AsSpan();
        for (int i = 0; i < files.Length; ++i)
        {
            ref var file = ref files[i];
            ref var list = ref file.<#= name #>NodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    <#= name #>.TryRegisterTrack(name, ((uint)i, index), queryFileId);
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }
<# } #>

    public bool CheckExistance()
    {
        var success = true;
        System.Text.StringBuilder? builder = null;
        var fileSpan = Files.AsSpan();

<# foreach (var name in array) { #>
<#  var offset = 0;
    switch (name){
        case "Scenario":
            offset = 10;
            break;
    }#>

        for (uint fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[(int)fileIndex];
            ref var set = ref file.<#= name #>Set;
            for (uint i = <#= offset #>, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGet<#= name #>Node(fileIndex, name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"<#= name.ToLowerInvariant() #> '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }
<# } #>

        for (uint fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[(int)fileIndex];
            ref var set = ref file.AttributeTypeSet;
            for (uint i = <#= Enum.GetNames(typeof(AttributeTypeKind)).Length #>, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (ContainsAttributeType(name))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"attribute type '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        if (!NodeValidator.CollectNames_UnitClassPowerSpot(fileSpan, ref AmbiguousDictionary_UnitClassPowerSpot))
        {
            NodeValidator.CollectError(fileSpan, ref SolutionErrorList, ref AmbiguousDictionary_UnitClassPowerSpot);
            success = false;
        }
        if (!NodeValidator.CollectNames_SkillSkillset(fileSpan, ref AmbiguousDictionary_SkillSkillset))
        {
            NodeValidator.CollectError(fileSpan, ref SolutionErrorList, ref AmbiguousDictionary_SkillSkillset);
            success = false;
        }

        return success;
    }
}
