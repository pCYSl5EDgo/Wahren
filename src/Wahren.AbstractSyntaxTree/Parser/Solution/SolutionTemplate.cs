#nullable enable
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
namespace Wahren.AbstractSyntaxTree.Parser;

public interface ISolutionResolver
{    ref Result TryGetScenarioNode(uint queryFileId, ReadOnlySpan<char> name, out uint index);
    ref Result TryGetEventNode(uint queryFileId, ReadOnlySpan<char> name, out uint index);
    ref Result TryGetStoryNode(uint queryFileId, ReadOnlySpan<char> name, out uint index);
    ref Result TryGetMovetypeNode(uint queryFileId, ReadOnlySpan<char> name, out uint index);
    ref Result TryGetSkillNode(uint queryFileId, ReadOnlySpan<char> name, out uint index);
    ref Result TryGetSkillsetNode(uint queryFileId, ReadOnlySpan<char> name, out uint index);
    ref Result TryGetRaceNode(uint queryFileId, ReadOnlySpan<char> name, out uint index);
    ref Result TryGetUnitNode(uint queryFileId, ReadOnlySpan<char> name, out uint index);
    ref Result TryGetClassNode(uint queryFileId, ReadOnlySpan<char> name, out uint index);
    ref Result TryGetPowerNode(uint queryFileId, ReadOnlySpan<char> name, out uint index);
    ref Result TryGetSpotNode(uint queryFileId, ReadOnlySpan<char> name, out uint index);
    ref Result TryGetFieldNode(uint queryFileId, ReadOnlySpan<char> name, out uint index);
    ref Result TryGetObjectNode(uint queryFileId, ReadOnlySpan<char> name, out uint index);
    ref Result TryGetDungeonNode(uint queryFileId, ReadOnlySpan<char> name, out uint index);
    ref Result TryGetVoiceNode(uint queryFileId, ReadOnlySpan<char> name, out uint index);

    ref Result TryResolveDetail(uint queryFileId, ReadOnlySpan<char> name, out ReferenceKind kind, out uint index);
    ref Result TryResolveUnitOrClass(uint queryFileId, ReadOnlySpan<char> name, out ReferenceKind kind, out uint index);
    ref Result TryResolveSkillOrSkillset(uint queryFileId, ReadOnlySpan<char> name, out ReferenceKind kind, out uint index);
}

public sealed class FailResolver : ISolutionResolver
{
    public static readonly FailResolver Default = new();
    public ref Result TryGetScenarioNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        index = 0;
        return ref Unsafe.NullRef<Result>();
    }
    public ref Result TryGetEventNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        index = 0;
        return ref Unsafe.NullRef<Result>();
    }
    public ref Result TryGetStoryNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        index = 0;
        return ref Unsafe.NullRef<Result>();
    }
    public ref Result TryGetMovetypeNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        index = 0;
        return ref Unsafe.NullRef<Result>();
    }
    public ref Result TryGetSkillNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        index = 0;
        return ref Unsafe.NullRef<Result>();
    }
    public ref Result TryGetSkillsetNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        index = 0;
        return ref Unsafe.NullRef<Result>();
    }
    public ref Result TryGetRaceNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        index = 0;
        return ref Unsafe.NullRef<Result>();
    }
    public ref Result TryGetUnitNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        index = 0;
        return ref Unsafe.NullRef<Result>();
    }
    public ref Result TryGetClassNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        index = 0;
        return ref Unsafe.NullRef<Result>();
    }
    public ref Result TryGetPowerNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        index = 0;
        return ref Unsafe.NullRef<Result>();
    }
    public ref Result TryGetSpotNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        index = 0;
        return ref Unsafe.NullRef<Result>();
    }
    public ref Result TryGetFieldNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        index = 0;
        return ref Unsafe.NullRef<Result>();
    }
    public ref Result TryGetObjectNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        index = 0;
        return ref Unsafe.NullRef<Result>();
    }
    public ref Result TryGetDungeonNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        index = 0;
        return ref Unsafe.NullRef<Result>();
    }
    public ref Result TryGetVoiceNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

    public ref Result TryResolveDetail(uint queryFileId, ReadOnlySpan<char> name, out ReferenceKind kind, out uint index)
    {
        kind = ReferenceKind.Spot; index = 0; return ref Unsafe.NullRef<Result>();
    }

    public ref Result TryResolveUnitOrClass(uint queryFileId, ReadOnlySpan<char> name, out ReferenceKind kind, out uint index)
    {
        kind = ReferenceKind.Unit; index = 0; return ref Unsafe.NullRef<Result>();
    }

    public ref Result TryResolveSkillOrSkillset(uint queryFileId, ReadOnlySpan<char> name, out ReferenceKind kind, out uint index)
    {
        kind = ReferenceKind.Skill; index = 0; return ref Unsafe.NullRef<Result>();
    }
}

public sealed partial class Solution : ISolutionResolver
{
	public ref Result TryGetScenarioNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        ref var pair = ref Scenario.TryGetTrack(name, queryFileId);
        if (!Unsafe.IsNullRef(ref pair))
        {
            index = pair.Id;
            return ref Files[pair.FileId];
        }
        
        var files = Files.AsSpan();
        for (int i = 0; i < files.Length; ++i)
        {
            ref var file = ref files[i];
            ref var list = ref file.ScenarioNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    Scenario.TryRegisterTrack(name, ((uint)i, index), queryFileId);
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetEventNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        ref var pair = ref Event.TryGetTrack(name, queryFileId);
        if (!Unsafe.IsNullRef(ref pair))
        {
            index = pair.Id;
            return ref Files[pair.FileId];
        }
        
        var files = Files.AsSpan();
        for (int i = 0; i < files.Length; ++i)
        {
            ref var file = ref files[i];
            ref var list = ref file.EventNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    Event.TryRegisterTrack(name, ((uint)i, index), queryFileId);
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetStoryNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        ref var pair = ref Story.TryGetTrack(name, queryFileId);
        if (!Unsafe.IsNullRef(ref pair))
        {
            index = pair.Id;
            return ref Files[pair.FileId];
        }
        
        var files = Files.AsSpan();
        for (int i = 0; i < files.Length; ++i)
        {
            ref var file = ref files[i];
            ref var list = ref file.StoryNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    Story.TryRegisterTrack(name, ((uint)i, index), queryFileId);
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetMovetypeNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        ref var pair = ref Movetype.TryGetTrack(name, queryFileId);
        if (!Unsafe.IsNullRef(ref pair))
        {
            index = pair.Id;
            return ref Files[pair.FileId];
        }
        
        var files = Files.AsSpan();
        for (int i = 0; i < files.Length; ++i)
        {
            ref var file = ref files[i];
            ref var list = ref file.MovetypeNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    Movetype.TryRegisterTrack(name, ((uint)i, index), queryFileId);
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetSkillNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        ref var pair = ref Skill.TryGetTrack(name, queryFileId);
        if (!Unsafe.IsNullRef(ref pair))
        {
            index = pair.Id;
            return ref Files[pair.FileId];
        }
        
        var files = Files.AsSpan();
        for (int i = 0; i < files.Length; ++i)
        {
            ref var file = ref files[i];
            ref var list = ref file.SkillNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    Skill.TryRegisterTrack(name, ((uint)i, index), queryFileId);
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetSkillsetNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        ref var pair = ref Skillset.TryGetTrack(name, queryFileId);
        if (!Unsafe.IsNullRef(ref pair))
        {
            index = pair.Id;
            return ref Files[pair.FileId];
        }
        
        var files = Files.AsSpan();
        for (int i = 0; i < files.Length; ++i)
        {
            ref var file = ref files[i];
            ref var list = ref file.SkillsetNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    Skillset.TryRegisterTrack(name, ((uint)i, index), queryFileId);
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetRaceNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        ref var pair = ref Race.TryGetTrack(name, queryFileId);
        if (!Unsafe.IsNullRef(ref pair))
        {
            index = pair.Id;
            return ref Files[pair.FileId];
        }
        
        var files = Files.AsSpan();
        for (int i = 0; i < files.Length; ++i)
        {
            ref var file = ref files[i];
            ref var list = ref file.RaceNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    Race.TryRegisterTrack(name, ((uint)i, index), queryFileId);
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetUnitNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        ref var pair = ref Unit.TryGetTrack(name, queryFileId);
        if (!Unsafe.IsNullRef(ref pair))
        {
            index = pair.Id;
            return ref Files[pair.FileId];
        }
        
        var files = Files.AsSpan();
        for (int i = 0; i < files.Length; ++i)
        {
            ref var file = ref files[i];
            ref var list = ref file.UnitNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    Unit.TryRegisterTrack(name, ((uint)i, index), queryFileId);
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetClassNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        ref var pair = ref Class.TryGetTrack(name, queryFileId);
        if (!Unsafe.IsNullRef(ref pair))
        {
            index = pair.Id;
            return ref Files[pair.FileId];
        }
        
        var files = Files.AsSpan();
        for (int i = 0; i < files.Length; ++i)
        {
            ref var file = ref files[i];
            ref var list = ref file.ClassNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    Class.TryRegisterTrack(name, ((uint)i, index), queryFileId);
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetPowerNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        ref var pair = ref Power.TryGetTrack(name, queryFileId);
        if (!Unsafe.IsNullRef(ref pair))
        {
            index = pair.Id;
            return ref Files[pair.FileId];
        }
        
        var files = Files.AsSpan();
        for (int i = 0; i < files.Length; ++i)
        {
            ref var file = ref files[i];
            ref var list = ref file.PowerNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    Power.TryRegisterTrack(name, ((uint)i, index), queryFileId);
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetSpotNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        ref var pair = ref Spot.TryGetTrack(name, queryFileId);
        if (!Unsafe.IsNullRef(ref pair))
        {
            index = pair.Id;
            return ref Files[pair.FileId];
        }
        
        var files = Files.AsSpan();
        for (int i = 0; i < files.Length; ++i)
        {
            ref var file = ref files[i];
            ref var list = ref file.SpotNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    Spot.TryRegisterTrack(name, ((uint)i, index), queryFileId);
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetFieldNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        ref var pair = ref Field.TryGetTrack(name, queryFileId);
        if (!Unsafe.IsNullRef(ref pair))
        {
            index = pair.Id;
            return ref Files[pair.FileId];
        }
        
        var files = Files.AsSpan();
        for (int i = 0; i < files.Length; ++i)
        {
            ref var file = ref files[i];
            ref var list = ref file.FieldNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    Field.TryRegisterTrack(name, ((uint)i, index), queryFileId);
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetObjectNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        ref var pair = ref Object.TryGetTrack(name, queryFileId);
        if (!Unsafe.IsNullRef(ref pair))
        {
            index = pair.Id;
            return ref Files[pair.FileId];
        }
        
        var files = Files.AsSpan();
        for (int i = 0; i < files.Length; ++i)
        {
            ref var file = ref files[i];
            ref var list = ref file.ObjectNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    Object.TryRegisterTrack(name, ((uint)i, index), queryFileId);
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetDungeonNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        ref var pair = ref Dungeon.TryGetTrack(name, queryFileId);
        if (!Unsafe.IsNullRef(ref pair))
        {
            index = pair.Id;
            return ref Files[pair.FileId];
        }
        
        var files = Files.AsSpan();
        for (int i = 0; i < files.Length; ++i)
        {
            ref var file = ref files[i];
            ref var list = ref file.DungeonNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    Dungeon.TryRegisterTrack(name, ((uint)i, index), queryFileId);
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetVoiceNode(uint queryFileId, ReadOnlySpan<char> name, out uint index)
    {
        ref var pair = ref Voice.TryGetTrack(name, queryFileId);
        if (!Unsafe.IsNullRef(ref pair))
        {
            index = pair.Id;
            return ref Files[pair.FileId];
        }
        
        var files = Files.AsSpan();
        for (int i = 0; i < files.Length; ++i)
        {
            ref var file = ref files[i];
            ref var list = ref file.VoiceNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    Voice.TryRegisterTrack(name, ((uint)i, index), queryFileId);
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

    public bool CheckExistance()
    {
        var success = true;
        System.Text.StringBuilder? builder = null;
        var fileSpan = Files.AsSpan();


        for (uint fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[(int)fileIndex];
            ref var set = ref file.ScenarioSet;
            for (uint i = 10, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetScenarioNode(fileIndex, name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"scenario '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        for (uint fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[(int)fileIndex];
            ref var set = ref file.EventSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetEventNode(fileIndex, name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"event '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        for (uint fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[(int)fileIndex];
            ref var set = ref file.StorySet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetStoryNode(fileIndex, name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"story '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        for (uint fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[(int)fileIndex];
            ref var set = ref file.MovetypeSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetMovetypeNode(fileIndex, name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"movetype '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        for (uint fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[(int)fileIndex];
            ref var set = ref file.SkillSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetSkillNode(fileIndex, name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"skill '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        for (uint fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[(int)fileIndex];
            ref var set = ref file.SkillsetSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetSkillsetNode(fileIndex, name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"skillset '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        for (uint fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[(int)fileIndex];
            ref var set = ref file.RaceSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetRaceNode(fileIndex, name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"race '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        for (uint fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[(int)fileIndex];
            ref var set = ref file.UnitSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetUnitNode(fileIndex, name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"unit '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        for (uint fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[(int)fileIndex];
            ref var set = ref file.ClassSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetClassNode(fileIndex, name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"class '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        for (uint fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[(int)fileIndex];
            ref var set = ref file.PowerSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetPowerNode(fileIndex, name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"power '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        for (uint fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[(int)fileIndex];
            ref var set = ref file.SpotSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetSpotNode(fileIndex, name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"spot '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        for (uint fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[(int)fileIndex];
            ref var set = ref file.FieldSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetFieldNode(fileIndex, name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"field '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        for (uint fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[(int)fileIndex];
            ref var set = ref file.ObjectSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetObjectNode(fileIndex, name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"object '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        for (uint fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[(int)fileIndex];
            ref var set = ref file.DungeonSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetDungeonNode(fileIndex, name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"dungeon '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        for (uint fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[(int)fileIndex];
            ref var set = ref file.VoiceSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetVoiceNode(fileIndex, name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"voice '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        for (uint fileIndex = 0; fileIndex < fileSpan.Length; ++fileIndex)
        {
            ref var file = ref fileSpan[(int)fileIndex];
            ref var set = ref file.AttributeTypeSet;
            for (uint i = 12, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (ContainsAttributeType(name))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"attribute type '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        if (!NodeValidator.CollectNames_UnitClassPowerSpot(fileSpan, ref AmbiguousDictionary_UnitClassPowerSpot))
        {
            NodeValidator.CollectError(fileSpan, ref SolutionErrorList, ref AmbiguousDictionary_UnitClassPowerSpot);
            success = false;
        }
        if (!NodeValidator.CollectNames_SkillSkillset(fileSpan, ref AmbiguousDictionary_SkillSkillset))
        {
            NodeValidator.CollectError(fileSpan, ref SolutionErrorList, ref AmbiguousDictionary_SkillSkillset);
            success = false;
        }

        return success;
    }
}
