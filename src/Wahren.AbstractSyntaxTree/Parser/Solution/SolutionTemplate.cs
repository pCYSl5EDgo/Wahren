#nullable enable
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
namespace Wahren.AbstractSyntaxTree.Parser;

public sealed partial class Solution : ISolutionResolver
{
	public ref Result TryGetScenarioNode(ReadOnlySpan<char> name, out uint index)
    {
        foreach (ref var file in Files)
        {
            ref var list = ref file.ScenarioNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetEventNode(ReadOnlySpan<char> name, out uint index)
    {
        foreach (ref var file in Files)
        {
            ref var list = ref file.EventNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetStoryNode(ReadOnlySpan<char> name, out uint index)
    {
        foreach (ref var file in Files)
        {
            ref var list = ref file.StoryNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetMovetypeNode(ReadOnlySpan<char> name, out uint index)
    {
        foreach (ref var file in Files)
        {
            ref var list = ref file.MovetypeNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetSkillNode(ReadOnlySpan<char> name, out uint index)
    {
        foreach (ref var file in Files)
        {
            ref var list = ref file.SkillNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetSkillsetNode(ReadOnlySpan<char> name, out uint index)
    {
        foreach (ref var file in Files)
        {
            ref var list = ref file.SkillsetNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetRaceNode(ReadOnlySpan<char> name, out uint index)
    {
        foreach (ref var file in Files)
        {
            ref var list = ref file.RaceNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetUnitNode(ReadOnlySpan<char> name, out uint index)
    {
        foreach (ref var file in Files)
        {
            ref var list = ref file.UnitNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetClassNode(ReadOnlySpan<char> name, out uint index)
    {
        foreach (ref var file in Files)
        {
            ref var list = ref file.ClassNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetPowerNode(ReadOnlySpan<char> name, out uint index)
    {
        foreach (ref var file in Files)
        {
            ref var list = ref file.PowerNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetSpotNode(ReadOnlySpan<char> name, out uint index)
    {
        foreach (ref var file in Files)
        {
            ref var list = ref file.SpotNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetFieldNode(ReadOnlySpan<char> name, out uint index)
    {
        foreach (ref var file in Files)
        {
            ref var list = ref file.FieldNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetObjectNode(ReadOnlySpan<char> name, out uint index)
    {
        foreach (ref var file in Files)
        {
            ref var list = ref file.ObjectNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetDungeonNode(ReadOnlySpan<char> name, out uint index)
    {
        foreach (ref var file in Files)
        {
            ref var list = ref file.DungeonNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

	public ref Result TryGetVoiceNode(ReadOnlySpan<char> name, out uint index)
    {
        foreach (ref var file in Files)
        {
            ref var list = ref file.VoiceNodeList;
            uint end = (uint)list.Count;
            if (end == 0)
            {
                continue;
            }

            for (index = 0; index != end; ++index)
            {
                ref var node = ref list[index];
                if (name.SequenceEqual(file.GetSpan(node.Name)))
                {
                    return ref file;
                }
            }
        }

        index = 0;
        return ref Unsafe.NullRef<Result>();
    }

    public bool CheckExistance()
    {
        var success = true;
        System.Text.StringBuilder? builder = null;
        foreach (ref var file in Files)
        {
            ref var set = ref file.ScenarioSet;
            for (uint i = 10, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetScenarioNode(name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"scenario '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }


        foreach (ref var file in Files)
        {
            ref var set = ref file.EventSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetEventNode(name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"event '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        foreach (ref var file in Files)
        {
            ref var set = ref file.StorySet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetStoryNode(name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"story '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        foreach (ref var file in Files)
        {
            ref var set = ref file.MovetypeSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetMovetypeNode(name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"movetype '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        foreach (ref var file in Files)
        {
            ref var set = ref file.SkillSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetSkillNode(name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"skill '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        foreach (ref var file in Files)
        {
            ref var set = ref file.SkillsetSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetSkillsetNode(name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"skillset '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        foreach (ref var file in Files)
        {
            ref var set = ref file.RaceSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetRaceNode(name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"race '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        foreach (ref var file in Files)
        {
            ref var set = ref file.UnitSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetUnitNode(name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"unit '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        foreach (ref var file in Files)
        {
            ref var set = ref file.ClassSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetClassNode(name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"class '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        foreach (ref var file in Files)
        {
            ref var set = ref file.PowerSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetPowerNode(name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"power '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        foreach (ref var file in Files)
        {
            ref var set = ref file.SpotSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetSpotNode(name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"spot '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        foreach (ref var file in Files)
        {
            ref var set = ref file.FieldSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetFieldNode(name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"field '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        foreach (ref var file in Files)
        {
            ref var set = ref file.ObjectSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetObjectNode(name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"object '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        foreach (ref var file in Files)
        {
            ref var set = ref file.DungeonSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetDungeonNode(name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"dungeon '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        foreach (ref var file in Files)
        {
            ref var set = ref file.VoiceSet;
            for (uint i = 0, end = set.Count; i != end ; i++)
            {
                var name = set[i];
                if (!Unsafe.IsNullRef(ref TryGetVoiceNode(name, out _)))
                {
                    continue;
                }

                success = false;
                builder ??= new();
                builder.Clear();
                builder.Append($"voice '{name}' is not found in this solution.");
                foreach (var tokenId in set.References[i].AsSpan())
                {
                    ref var position = ref file.TokenList[tokenId].Range.StartInclusive;
                    builder.Append($"\n  {file.FilePath}({position.Line + 1}, {position.Offset + 1})");
                }
                SolutionErrorList.Add(new(builder.ToString()));
            }
        }

        return success;
    }
}
