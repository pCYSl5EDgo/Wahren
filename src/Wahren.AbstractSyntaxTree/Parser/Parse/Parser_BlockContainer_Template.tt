<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.TextTemplateHelper.dll" #>
<#@ import namespace="Wahren.AbstractSyntaxTree.TextTemplateHelper" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#nullable enable
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System.Buffers.Binary;
using System.Runtime.InteropServices;

namespace Wahren.AbstractSyntaxTree.Parser;
using Element.Statement;

public static partial class Parser
{
<#
foreach (string name in Helper.BlockContainers) {
    ElementInfo[] array = ElementInfo.Get(name);
    var len1 = array.Where(x => x.name.Length == 1).ToArray();
    var len2 = array.Where(x => x.name.Length == 2).ToArray();
    var len3 = array.Where(x => x.name.Length == 3).ToArray();
    var usageGroup = array.MakeUsageGroup();
#>
    private static bool Parse<#= name #>(ref Context context, ref Result result, out bool canContinue)
    {
        result.<#= name #>NodeList.Add(new());
        ref var node = ref result.<#= name #>NodeList.Last;
        ref var tokenList = ref result.TokenList;
        node.Kind = tokenList.LastIndex;
        canContinue = false;
        if (!ParseNameAndSuperAndBracketLeft(ref context, ref result, ref node, ref result.<#= name #>Set))
        {
            return false;
        }

        var createErrorWarning = context.CreateError(DiagnosticSeverity.Warning);
        uint variant = uint.MaxValue;
        ref var source = ref result.Source;
        List<IBlockStatement> blockStack = new();
<#  foreach (var (type, outers) in usageGroup) {
        foreach (var ((trailer, func), _) in outers) { #>
        ref var element_<#= trailer #> = ref Unsafe.NullRef<<#= type #>?>();
<#      }
    }#>
        ulong key = 0UL;
        do
        {
            if (!ReadUsefulToken(ref context, ref result))
            {
                result.ErrorAdd_BracketRightNotFound(node.Kind, node.Name);
                goto FALSE;
            }

            var currentIndex = tokenList.LastIndex;
            if (tokenList.Last.IsBracketRight(ref source))
            {
                node.BracketRight = currentIndex;
                blockStack.Dispose();
                canContinue = true;
                return true;
            }

            if (!ReadToken(ref context, ref result))
            {
                result.ErrorAdd_UnexpectedEndOfFile(tokenList.LastIndex, "'=' or '(' is expected but not found.");
                goto FALSE;
            }
            
            if (!tokenList.Last.IsAssign(ref source))
            {
                if (tokenList.Last.IsParenLeft(ref source))
                {
                    if (Parse_RootBlock(ref context, ref result, currentIndex, ref node.Statements, ref blockStack))
                    {
                        continue;
                    }

                    goto FALSE;
                }
<#  if (name == "Event") { #>
                else if (tokenList.Last.IsBracketLeft(ref source) && result.GetSpan(currentIndex).SequenceEqual("battle"))
                {
                    NextStatement? nextStatement = null;
                    foreach (ref var statement in node.Statements)
                    {
                        if ((nextStatement = statement as NextStatement) is not null)
                        {
                            break;
                        }
                    }
                        
                    if (nextStatement is null)
                    {
                        result.ErrorList.Add(new("'battle{}' block does not have corresponding 'next()' statement.", tokenList[currentIndex].Range));
                    }

                    var battleStatement = new BattleStatement(currentIndex, nextStatement);
                    tokenList[currentIndex].Kind = TokenKind.battle;
                    blockStack.Add(battleStatement);
                    var answer = Parse_Block(ref context, ref result, ref battleStatement.Statements, ref blockStack);
                    blockStack.RemoveLast();
                    if (answer)
                    {
                        continue;
                    }
                        
                    goto FALSE;
                }
<#  } #> 
                   
                result.ErrorAdd_UnexpectedOperatorToken(tokenList.LastIndex, "'=' or '(' is expected but not found.");
                goto FALSE;
            }

<# if (ElementInfo.IsAllScenarioVariant(name)) { #>
            if (!result.SplitElement(currentIndex, out var span, out variant))
<# } else { #>
            if (!result.SplitElementPlain(currentIndex, out var span, out var variantSpan))
<# } #>
            {
                return false;
            }

            var byteSpan = MemoryMarshal.Cast<char, byte>(span);
            var originalLength = span.Length;
            switch (originalLength)
            {
                case 0: return false;
                case 1:
<#  if (len1.Length != 0) { #>
                    switch (span[0])
                    {
<#      foreach (var item in len1) { #>
                        case '<#= item.name[0] #>': element_<#= item.name.GetCorrespondingTrailer() #> = ref node.<#= item.name.Escape() #>.EnsureGet(variant<# if (!ElementInfo.IsAllScenarioVariant(name)) { #> = result.<#= item.variantType #>Set.GetOrAdd(variantSpan, currentIndex)<# } #>); goto <#= item.name.GetCorrespondingTrailer() #>;
<#      } #>
                    }
<#  } #>
                    key = ((ulong)byteSpan[0]) | ((ulong)byteSpan[1] << 8);
                    span = Span<char>.Empty;
                    goto DISCARD;
                case 2:
                    key = BinaryPrimitives.ReadUInt32LittleEndian(byteSpan);
<#  if (len2.Length != 0) { #>
                    switch ((uint)key)
                    {
<#      foreach (var item in len2) { #>
                        case 0x<#= item.name.GetKey().ToString("X8") #>U: element_<#= item.name.GetCorrespondingTrailer() #> = ref node.<#= item.name.Escape() #>.EnsureGet(variant<# if (!ElementInfo.IsAllScenarioVariant(name)) { #> = result.<#= item.variantType #>Set.GetOrAdd(variantSpan, currentIndex)<# } #>); goto <#= item.name.GetCorrespondingTrailer() #>;
<#      } #>
                    }
<#  } #>
                    span = Span<char>.Empty;
                    goto DISCARD;
                case 3:
                    key = BinaryPrimitives.ReadUInt32LittleEndian(byteSpan) | (((ulong)BinaryPrimitives.ReadUInt16LittleEndian(byteSpan.Slice(4))) << 32);
<#  if (len3.Length != 0) { #>
                    switch (key)
                    {
<#      foreach (var item in len3) { #>
                        case 0x<#= item.name.GetKey().ToString("X12") #>UL: element_<#= item.name.GetCorrespondingTrailer() #> = ref node.<#= item.name.Escape() #>.EnsureGet(variant<# if (!ElementInfo.IsAllScenarioVariant(name)) { #> = result.<#= item.variantType #>Set.GetOrAdd(variantSpan, currentIndex)<# } #>); goto <#= item.name.GetCorrespondingTrailer() #>;
<#      } #>
                    }
<#  } #>
                    span = Span<char>.Empty;
                    goto DISCARD;
            }

            key = System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian(byteSpan);
            span = span.Slice(4);
            switch (span.Length)
            {
<# foreach (var (len, items) in array.MakeGroup()) { if (len < 4) continue; #>
                case <#= len - 4 #>:
                    switch (key)
                    {
<#  foreach (var (element, key, rest) in items) { #>
                        case 0x<#= key #>UL<# if (element.name.Length == 5) { #> when span[0] == '<#= rest[0] #>'<# } else { #> when span.SequenceEqual("<#= rest #>")<# } #>: element_<#= element.name.GetCorrespondingTrailer() #> = ref node.<#= element.name.Escape() #>.EnsureGet(variant<# if (!ElementInfo.IsAllScenarioVariant(name)) { #> = result.<#= element.variantType #>Set.GetOrAdd(variantSpan, currentIndex)<# } #>); goto <#= element.name.GetCorrespondingTrailer() #>;                            
<#  } #>
                    }
                    break;
<# } #>
            }

        DISCARD:
            if (Parse_Discard(ref context, ref result, currentIndex, span, key))
            {
                if (createErrorWarning)
                {
                    result.WarningAdd_UnexpectedElementName(node.Kind, currentIndex);
                }
                continue;
            }
            else
            {
                goto FALSE;
            }

<# foreach (var (type, outers) in usageGroup) {
    foreach (var ((trailer, func), _) in outers) { #>
        <#= trailer #>:
            if (element_<#= trailer #> is null)
            {
                element_<#= trailer #> = new(currentIndex);
                element_<#= trailer #>.ElementScenarioId = variant;
                element_<#= trailer #>.ElementKeyRange.Length = (uint)originalLength;
                {
                    ref var start = ref tokenList[currentIndex].Range.StartInclusive;
                    element_<#= trailer #>.ElementKeyRange.Line = start.Line;
                    element_<#= trailer #>.ElementKeyRange.Offset = start.Offset;
                }
                if (<#= func #>(ref context, ref result, element_<#= trailer #>))
                {
                    continue;
                }
                else
                {
                    goto FALSE;
                }
            }
            
            if (createErrorWarning)
            {
                result.WarningAdd_MultipleAssignment(currentIndex);
            }

            if (Parse_Discard_<#= trailer #>(ref context, ref result, currentIndex))
            {
                continue;
            }
            else
            {
                goto FALSE;
            }
<#  }
}#>
        } while (true);

    FALSE:
        blockStack.Dispose();
        return false;
    }
<#}#>
}
