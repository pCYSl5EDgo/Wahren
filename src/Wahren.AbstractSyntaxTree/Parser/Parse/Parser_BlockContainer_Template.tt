<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Memory" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.Basic.dll" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.TextTemplateHelper.dll" #>
<#@ import namespace="Wahren.AbstractSyntaxTree" #>
<#@ import namespace="Wahren.AbstractSyntaxTree.TextTemplateHelper" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#nullable enable
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
namespace Wahren.AbstractSyntaxTree.Parser;

using Statement;

public static partial class Parser
{
<#
foreach (var node in NodeInfo.Nodes.Where(x => x.HasBlock)) {
    ElementInfo[] elements = node.Elements;
    var usageGroup = elements.MakeUsageGroup();
#>
    private static bool Parse<#= node.Name #>(ref Context context, ref Result result, out bool canContinue)
    {
        result.<#= node.Name #>NodeList.Add(new());
        ref var node = ref result.<#= node.Name #>NodeList.Last;
        ref var tokenList = ref result.TokenList;
        node.Kind = tokenList.LastIndex;
        canContinue = false;
        if (!ParseNameAndSuperAndBracketLeft(ref context, ref result, ref node, ref result.<#= node.Name #>Set))
        {
            return false;
        }

        var createErrorWarning = context.CreateError(DiagnosticSeverity.Warning);
        uint variant = uint.MaxValue;
        ref var source = ref result.Source;
        List<IBlockStatement> blockStack = new();
<#  foreach (var (type, _) in usageGroup) { #>
        ref var pair_<#= type #> = ref Unsafe.NullRef<<#= type #>?>();
<#  } #>
        ulong key = 0UL;
        do
        {
            if (!ReadUsefulToken(ref context, ref result))
            {
                result.ErrorAdd_BracketRightNotFound(node.Kind, node.Name);
                goto FALSE;
            }

            var currentIndex = tokenList.LastIndex;
            if (tokenList.Last.IsBracketRight(ref source))
            {
                node.BracketRight = currentIndex;
                blockStack.Dispose();
                canContinue = true;
                return true;
            }

            if (!ReadToken(ref context, ref result))
            {
                result.ErrorAdd_UnexpectedEndOfFile_AssignmentOrParenLeftIsExpected();
                goto FALSE;
            }
            
            if (!tokenList.Last.IsAssign(ref source))
            {
                if (tokenList.Last.IsParenLeft(ref source))
                {
                    if (Parse_RootBlock(ref context, ref result, currentIndex, ref node.Statements, ref blockStack))
                    {
                        continue;
                    }

                    goto FALSE;
                }
<#  if (node.Name == "Event") { #>
                else if (tokenList.Last.IsBracketLeft(ref source) && result.GetSpan(currentIndex).SequenceEqual("battle"))
                {
                    NextStatement? nextStatement = null;
                    foreach (ref var statement in node.Statements)
                    {
                        if ((nextStatement = statement as NextStatement) is not null)
                        {
                            break;
                        }
                    }
                        
                    if (nextStatement is null)
                    {
                        result.ErrorAdd_CoresspondingNextDoesNotExist(currentIndex);
                    }

                    var battleStatement = new BattleStatement(currentIndex, nextStatement);
                    tokenList[currentIndex].Kind = TokenKind.battle;
                    blockStack.Add(battleStatement);
                    var answer = Parse_Block(ref context, ref result, ref battleStatement.Statements, ref blockStack);
                    blockStack.RemoveLast();
                    if (answer)
                    {
                        continue;
                    }
                        
                    goto FALSE;
                }
<#  } #> 
                   
                result.ErrorAdd_UnexpectedOperatorToken(tokenList.LastIndex, "'=' or '(' is expected but not found.");
                goto FALSE;
            }

<# if (node.IsAllScenarioVariant) { #>
            if (!result.SplitElement(currentIndex, out var span, out variant))
<# } else { #>
            if (!result.SplitElementPlain(currentIndex, out var span, out var variantSpan))
<# } #>
            {
                return false;
            }

            key = StringHashUtility.Calc(span);
            switch (span.Length)
            {
<#  foreach (var (len, items) in elements.MakeGroup()) { #>
                case <#= len #>:
                    switch (key)
                    {
<#      foreach (var (item, key, rest) in items) {
            var type = item.Type;
            var trailer = item.Name.GetCorrespondingTrailer(); #>
                        case 0x<#= key #>UL<# if (len == StringHashUtility.HashLengthMax + 1) { #> when span[StringHashUtility.HashLengthMax] == '<#= rest[0] #>'<# } else if (len > StringHashUtility.HashLengthMax + 1) { #> when span.Slice(StringHashUtility.HashLengthMax).SequenceEqual("<#= rest #>")<# } #>:
<#          if (item.VariantType == "") { #>
                            if (variantSpan.Length != 0)
                            {
                                result.ErrorAdd_VariantNotAllowed(node.Kind, currentIndex);
                            }
                            variant = uint.MaxValue;
                            pair_<#= type #> = ref node.<#= item.Name.Escape() #>;
<#          } else if (node.IsAllScenarioVariant) { #>
                            pair_<#= type #> = ref node.<#= item.Name.Escape() #>.EnsureGet(variant);
<#          } else { #>
                            pair_<#= type #> = ref node.<#= item.Name.Escape() #>.EnsureGet(variant = result.<#= item.VariantType #>Set.GetOrAdd(variantSpan, currentIndex));
<#          } #>
                            goto <#= trailer #>;
<#      } #>
                    }
                    break;
<#  } #>
            }

            if (Parse_Discard(ref context, ref result, currentIndex, key))
            {
                result.ErrorAdd_UnexpectedElementName(node.Kind, currentIndex);
                continue;
            }
            else
            {
                goto FALSE;
            }

<# foreach (var (type, outers) in usageGroup) {
    foreach (var ((trailer, func), _) in outers) { #>
        <#= trailer #>:
            if (pair_<#= type #> is null)
            {
                pair_<#= type #> = new(currentIndex);
                pair_<#= type #>.ElementScenarioId = variant;
                pair_<#= type #>.ElementKeyRange.Length = (uint)span.Length;
                {
                    ref var start = ref tokenList[currentIndex].Position;
                    pair_<#= type #>.ElementKeyRange.Line = start.Line;
                    pair_<#= type #>.ElementKeyRange.Offset = start.Offset;
                }
                if (<#= func #>(ref context, ref result, pair_<#= type #>))
                {
                    continue;
                }
                else
                {
                    goto FALSE;
                }
            }
            
            if (createErrorWarning)
            {
                result.WarningAdd_MultipleAssignment(currentIndex);
            }

            if (Parse_Discard_<#= trailer #>(ref context, ref result, currentIndex))
            {
                continue;
            }
            else
            {
                goto FALSE;
            }
<#  }
}#>
        } while (true);

    FALSE:
        blockStack.Dispose();
        return false;
    }
<#}#>
}
