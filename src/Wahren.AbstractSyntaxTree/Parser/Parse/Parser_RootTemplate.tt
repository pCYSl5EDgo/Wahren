<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Memory" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.Basic.dll" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.TextTemplateHelper.dll" #>
<#@ import namespace="Wahren" #>
<#@ import namespace="Wahren.AbstractSyntaxTree" #>
<#@ import namespace="Wahren.AbstractSyntaxTree.TextTemplateHelper" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#nullable enable
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
namespace Wahren.AbstractSyntaxTree.Parser;
<# var tupleArray = new (ulong, string, string)[] {
(StringHashUtility.Calc("attribute"), "Attribute", "attribute"),
(StringHashUtility.Calc("context"), "Context", "context"),
(StringHashUtility.Calc("class"), "Class", "class"),
(StringHashUtility.Calc("detail"), "Detail", "detail"),
(StringHashUtility.Calc("dungeon"), "Dungeon", "dungeon"),
(StringHashUtility.Calc("event"), "Event", "event"),
(StringHashUtility.Calc("field"), "Field", "field"),
(StringHashUtility.Calc("fight"), "Event", "fight"),
(StringHashUtility.Calc("movetype"), "Movetype", "movetype"),
(StringHashUtility.Calc("object"), "Object", "object"),
(StringHashUtility.Calc("power"), "Power", "power"),
(StringHashUtility.Calc("race"), "Race", "race"),
(StringHashUtility.Calc("scenario"), "Scenario", "scenario"),
(StringHashUtility.Calc("skill"), "Skill", "skill"),
(StringHashUtility.Calc("skillset"), "Skillset", "skillset"),
(StringHashUtility.Calc("sound"), "Sound", "sound"),
(StringHashUtility.Calc("spot"), "Spot", "spot"),
(StringHashUtility.Calc("story"), "Story", "story"),
(StringHashUtility.Calc("unit"), "Unit", "unit"),
(StringHashUtility.Calc("voice"), "Voice", "voice"),
(StringHashUtility.Calc("workspace"), "Workspace", "workspace"),
(StringHashUtility.Calc("world"), "Event", "world"),
}; #>

public static partial class Parser
{
	public static bool Parse(ref Context context, ref Result result)
    {
        ref var source = ref result.Source;
        if (source.Count != 0 && source[0].Count != 0 && source[0][0] == '\ufeff')
        {
            source[0].RemoveAt(0);
        }

        ref var tokenList = ref result.TokenList;
        while (ReadUsefulToken(ref context, ref result))
        {
            var hash = StringHashUtility.Calc(result.GetSpan(tokenList.LastIndex));
            switch (hash)
            {
<# foreach (var (hash, name, kind) in tupleArray.OrderBy(x => x.Item1)) { #>
                case 0x<#= hash.ToString("X16") #>UL:
                    tokenList.GetKind(tokenList.LastIndex) = TokenKind.<#= kind.Escape() #>;
                    if (!Parse<#= name #>(ref context, ref result))
                    {
                        return false;
                    }
                    break;
<# } #>
                default:
                    result.ErrorAdd_StructureKindOrCommentIsExpected();
                    return false;
            }
        }

        return true;
    }
}
