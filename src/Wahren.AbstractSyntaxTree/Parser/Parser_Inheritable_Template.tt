<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.TextTemplateHelper.dll" #>
<#@ import namespace="Wahren.AbstractSyntaxTree.TextTemplateHelper" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
#nullable enable
using System.Buffers.Binary;
using System.Runtime.InteropServices;

namespace Wahren.AbstractSyntaxTree.Parser;

public static partial class Parser
{
<# foreach (var name in Helper.Inheritables) {
    string[] array = Helper.Get(name);
    var len1 = array.Where(x => x.Length == 1).ToArray();
    var len2 = array.Where(x => x.Length == 2).ToArray();
    var len3 = array.Where(x => x.Length == 3).ToArray();
    var usageGroup = array.MakeUsageGroup(); #>
    private static bool Parse<#= name #>(ref Context context, ref Result result)
    {
        result.<#= name #>NodeList.Add(new());
        ref var tokenList = ref result.TokenList;
        ref var node = ref result.<#= name #>NodeList.Last;
        node.Kind = tokenList.LastIndex;
        if (!ParseNameAndSuperAndBracketLeft(ref context, ref result, ref node, ref result.<#= name #>Set))
        {
            return false;
        }

        var createErrorWarning = context.CreateError(DiagnosticSeverity.Warning);
        ref var source = ref result.Source;
<#  foreach (var (type, outers) in usageGroup) {
        foreach (var ((trailer, func), _) in outers) { #>
        ref var pair_<#= trailer #> = ref Unsafe.NullRef<<#= type #>?>();
<#      }
    }#>
        ulong key = 0UL;
        do
        {
            if (!ReadUsefulToken(ref context, ref result))
            {
                result.ErrorAdd_BracketRightNotFound(node.Kind, node.Name);
                return false;
            }

            if (tokenList.Last.IsBracketRight(ref source))
            {
                node.BracketRight = tokenList.LastIndex;
                return true;
            }

            var currentIndex = tokenList.LastIndex;
<# if (name == "Skill") { #>
            uint scenarioVariant;
            if (!result.SplitElementPlain(currentIndex, out var span, out var variantSpan))
            {
                return false;
            }
            if (span.SequenceEqual("msg") || span.SequenceEqual("picture"))
            {
                scenarioVariant = result.UnitSet.GetOrAdd(variantSpan);
            }
            else
            {
                scenarioVariant = result.ScenarioSet.GetOrAdd(variantSpan);
            }
<# } else { #>
            if (!result.SplitElement(currentIndex, out var span, out var scenarioVariant))
            {
                return false;
            }
<# } #>
            if (!ReadToken(ref context, ref result))
            {
                result.ErrorAdd_UnexpectedEndOfFile(tokenList.LastIndex, "'=' is expected but not found.");
                return false;
            }
            
            if (!tokenList.Last.IsAssign(ref source))
            {
                result.ErrorAdd_UnexpectedOperatorToken(tokenList.LastIndex, "'=' is expected but not found.");
                return false;
            }

            var byteSpan = MemoryMarshal.Cast<char, byte>(span);
            var originalLength = span.Length;
            switch (originalLength)
            {
                case 0: return false;
                case 1:
<#  if (len1.Length != 0) { #>
                    switch (span[0])
                    {
<#      foreach (var item in len1) { #>
                        case '<#= item[0] #>': pair_<#= item.GetCorrespondingTrailer() #> = ref node.<#= item.Escape() #>.EnsureGet(scenarioVariant); goto <#= item.GetCorrespondingTrailer() #>;
<#      } #>
                    }
<#  }
    if(Helper.IsAllowedUndefinedContent(name)) { #>
                    goto DEFAULT_OTHERS;
<#  } else { #>
                    key = ((ulong)byteSpan[0]) | ((ulong)byteSpan[1] << 8);
                    span = Span<char>.Empty;
                    goto DISCARD;
<#  }#>
                case 2:
                    key = BinaryPrimitives.ReadUInt32LittleEndian(byteSpan);
<#  if (len2.Length != 0) { #>
                    switch ((uint)key)
                    {
<#      foreach (var item in len2) { #>
                        case 0x<#= item.GetKey().ToString("X8") #>U: pair_<#= item.GetCorrespondingTrailer() #> = ref node.<#= item.Escape() #>.EnsureGet(scenarioVariant); goto <#= item.GetCorrespondingTrailer() #>;
<#      } #>
                    }
<#  }if(Helper.IsAllowedUndefinedContent(name)) { #>
                    goto DEFAULT_OTHERS;
<#  } else { #>
                    span = Span<char>.Empty;
                    goto DISCARD;
<#  }#>
                case 3:
                    key = BinaryPrimitives.ReadUInt32LittleEndian(byteSpan) | (((ulong)BinaryPrimitives.ReadUInt16LittleEndian(byteSpan.Slice(4))) << 32);
<#  if (len3.Length != 0) { #>
                    switch (key)
                    {
<#      foreach (var item in len3) { #>
                        case 0x<#= item.GetKey().ToString("X12") #>UL: pair_<#= item.GetCorrespondingTrailer() #> = ref node.<#= item.Escape() #>.EnsureGet(scenarioVariant); goto <#= item.GetCorrespondingTrailer() #>;
<#      } #>
                    }
<#  }
    if(Helper.IsAllowedUndefinedContent(name)) { #>
                    goto DEFAULT_OTHERS;
<#  } else { #>
                    span = Span<char>.Empty;
                    goto DISCARD;
<#  }#>
            }

            key = BinaryPrimitives.ReadUInt64LittleEndian(byteSpan);
            span = span.Slice(4);
            switch (span.Length)
            {
<#  foreach (var (len, items) in array.MakeGroup()) { if (len < 4) continue; #>
                case <#= len - 4 #>:
                    switch (key)
                    {
<#      foreach (var (item, key, rest) in items) { #>
                        case 0x<#= key #>UL<# if (len == 5) { #> when span[0] == '<#= rest[0] #>'<# } else if (len != 4) { #> when span.SequenceEqual("<#= rest #>")<# } #>: pair_<#= item.GetCorrespondingTrailer() #> = ref node.<#= item.Escape() #>.EnsureGet(scenarioVariant); goto <#= item.GetCorrespondingTrailer() #>;
<#      } #>
                    }
                    goto default;
<#  } #>
                default:
                    span = MemoryMarshal.Cast<byte, char>(byteSpan);
                    goto <# if(Helper.IsAllowedUndefinedContent(name)) { #>DEFAULT_OTHERS<# } else { #>DISCARD<# } #>;
            }

<#  foreach (var (type, outers) in usageGroup) {
        foreach (var ((trailer, func), _) in outers) { #>
        <#= trailer #>:
            if (pair_<#= trailer #> is null)
            {
                pair_<#= trailer #> = new(currentIndex);
                pair_<#= trailer #>.ElementScenarioId = scenarioVariant;
                pair_<#= trailer #>.ElementKeyRange.Length = (uint)originalLength;
                {
                    ref var start = ref tokenList[currentIndex].Range.StartInclusive;
                    pair_<#= trailer #>.ElementKeyRange.Line = start.Line;
                    pair_<#= trailer #>.ElementKeyRange.Offset = start.Offset;
                }
                if (<#= func #>(ref context, ref result, pair_<#= trailer #>))
                {
                   continue;
                }

                return false;
            }

            if (createErrorWarning)
            {
                result.WarningAdd_MultipleAssignment(currentIndex);
            }
                
            if (Parse_Discard_<#= trailer #>(ref context, ref result, currentIndex))
            {
                continue;
            }
            else
            {
                return false;
            }
<#      }
    } #>
<#  if (Helper.IsAllowedUndefinedContent(name)) { #>
        DEFAULT_OTHERS:
            foreach (ref var other in node.Others)
            {
                if (other.EqualsKey(span, ref result))
                {
                    pair_DEFAULT = ref other.EnsureGet(scenarioVariant);
                    goto DEFAULT;
                }
            }

            node.Others.Add(new());
            pair_DEFAULT = ref node.Others.Last.EnsureGet(scenarioVariant);
            goto DEFAULT;
<#  } else { #>
        DISCARD:
            if (Parse_Discard(ref context, ref result, currentIndex, span, key))
            {
                if (createErrorWarning)
                {
                    result.WarningAdd_UnexpectedElementName(node.Kind, currentIndex);
                }
                continue;
            }
            else
            {
                return false;
            }
<#  }#>
        } while (true);
    }

<# } #>
}
