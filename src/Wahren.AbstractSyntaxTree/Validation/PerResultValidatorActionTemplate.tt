<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.TextTemplateHelper.dll" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.Basic.dll" #>
<#@ import namespace="Wahren.AbstractSyntaxTree" #>
<#@ import namespace="Wahren.AbstractSyntaxTree.TextTemplateHelper" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
#nullable enable

namespace Wahren.AbstractSyntaxTree.Parser;

using Statement;
using Statement.Expression;

public static partial class PerResultValidator
{<# foreach ((string callableKind, string callableTrailer, CallableInfo[] callableInfoArray) in new (string, string, CallableInfo[])[] { ("Action", "Statement", CallableInfo.ActionInfoNormals), ("Function", "Expression", CallableInfo.FunctionInfoNormals) }) { #>

    public static void AddReferenceAndValidate(ref Context context, ref Result result, Call<#= callableKind #><#= callableTrailer #> call)
    {
        var arguments = call.Arguments.AsSpan();
        if (arguments.IsEmpty)
        {
            return;
        }

        ref var argument = ref arguments[0];
        ReadOnlySpan<char> span;
        switch (call.Kind)
        {
<# foreach (((int min, int max), IEnumerable<(string, ReferenceKind[][])> groupEnumerable) in callableInfoArray.GroupBy(
        item => (item.Min, item.Max),
        item => (item.Name, item.KindArray),
        (key, values) => (key, values)
    )
) { #>
<#  if (min == max && min == 0) { continue; } #>
<#  if (min == 0 && max == int.MaxValue) { #>
<#      foreach ((string name, ReferenceKind[][] arrayArray) in groupEnumerable) { #>
            case <#= callableKind #>Kind.<#= name.Escape() #>:
                if (context.CreateError(DiagnosticSeverity.Warning))
                {
                    result.WarningAdd($"Unknown action '<#= name #>'.", call.TokenId);
                }
                break;
<#      } #>
<#  } #>
<#  else { #>
<#      foreach ((string name, ReferenceKind[][] arrayArray) in groupEnumerable.Where(x => x.Item2.CanProcessEarly())) { #>
            case <#= callableKind #>Kind.<#= name.Escape() #>:
<#          ReferenceKind[] array; #>
<#          if (arrayArray.Length == 0) { #>
                // skip <#= name #>
                break;
<#              continue; #>
<#          } #>
<#          if (arrayArray.Length > 1) { #>
                switch (arguments.Length)
                {
<#              for (int j = min; j <= max; ++j) { #>
<#                  array = arrayArray[j - min]; #>
                    case <#= j #>:
<#                  for (int i = 0; i < j; ++i) { #>
<#                      var reference = array[i]; #>
                        <#= reference.ProcessEarly(i, name, 6) #><#                  } #>
                        break;
<#              } #>
                }
                break;
<#              continue; #>
<#          } #>
<#          array = arrayArray[0]; #>
<#          if (array.Length == 0) { #>
                AddReferenceAndValidate_Action_<#= name #>(ref context, ref result, call);
<#          } else if (min == max) { #>
<#              for (int i = 0; i < array.Length; ++i) { var reference = array[i]; #>
                <#= reference.ProcessEarly(i, name, 4) #>
<#              } #>
<#          } else { #>
<#              if (array.Length == min) { #>
<#                  for (int i = 0; i < array.Length; ++i) { ReferenceKind reference = array[i]; #>
                <#= reference.ProcessEarly(i, name, 4) #>
<#                  } #>
<#                  if (array[array.Length - 1].CanProcessEarly()) { #>
                for (int i = <#= array.Length #>; i < arguments.Length; ++i)
                {
                    <#= array[array.Length - 1].ProcessEarly(-1, name, 5) #>
                }
<#                  } #>
<#              } else if (array.Length == max) { #>
<#                  for (int i = 0; i < min; ++i) { ReferenceKind reference = array[i]; #>
                <#= reference.ProcessEarly(i, name, 4) #>
<#                  } #>
<#                  for (int i = min; i < array.Length; ++i) { ReferenceKind reference = array[i]; #>
<#                      if (i != 0 && array[i].CanProcessEarly()) { #>
                if (arguments.Length <= <#= i #>)
                {
                    break;
                }
<#                      } #>
                <#= reference.ProcessEarly(i, name, 4) #>
<#                  } #>
<#              } else { #>
<#                  for (int i = 0; i < min; ++i) { ReferenceKind reference = array[i]; #>
                <#= reference.ProcessEarly(i, name, 4) #>
<#                  } #>
<#                  for (int i = min; i < array.Length; ++i) { ReferenceKind reference = array[i]; #>
<#                      if (i != 0 && array[i].CanProcessEarly()) { #>
                if (arguments.Length <= <#= i #>)
                {
                    break;
                }
<#                      } #>
                <#= reference.ProcessEarly(i, name, 4) #>
<#                  } #>
<#                  if (array[array.Length - 1].CanProcessEarly()) { #>
                for (int i = <#= array.Length #>; i < arguments.Length; ++i)
                {
                    <#= array[array.Length - 1].ProcessEarly(-1, name, 5) #>
                }
<#                  } #>
<#              }#>
<#          } #>
                break;
<#      } #>
<#  } #>
<# } #>
        }
    }

    public static bool ArgumentCountValidation(ref Context context, ref Result result, <#= callableKind #>Kind kind, int count, uint index)
    {
        if (count < 0)
        {
            return false;
        }

		switch (kind)
        {
<#
foreach (((int min, int max), string[] itemArray) in callableInfoArray.GroupBy(
    item => (item.Min, item.Max),
    item => item.Name,
    (key, values) => (key, values.ToArray()))
) {
	if (min == 0 && max == int.MaxValue) continue;
	for (var index = 0; index < itemArray.Length; ++index) {
#>
            case <#= callableKind #>Kind.<#= itemArray[index].Escape() #>:
<#	}  #>
<#	var item = itemArray[itemArray.Length - 1]; #>
<#  if (min == max && min == 0) { #>
				if (count != 0)
                {
                    if (context.CreateError(DiagnosticSeverity.Warning))
                    {
                        result.WarningAdd($"There are too many arguments({count}) for '{kind}'. Exceeding arguments are just ignored. Required: 0.", index);
                    }
                    return false;
                }
<#  } else if (max == int.MaxValue) { #>
                if (count < <#= min #>)
                {
                    result.ErrorAdd($"There are too less arguments({count}) for '{kind}'. Required: <#= min #>~.", index);
                    return false;
                }
<#  } else if (min == 0) { #>
				if (count > <#= max #>)
                {
                    if (context.CreateError(DiagnosticSeverity.Warning))
                    {
                        result.WarningAdd($"There are too many arguments({count}) for '{kind}'. Exceeding arguments are just ignored. Required: 0~<#= max #>.", index);
                    }
                    return false;
                }
<#  } else if (min == max) { #>
                if (count < <#= min #>)
                {
                    result.ErrorAdd($"There are too less arguments({count}) for '{kind}'. Required: <#= min #>.", index);
                    return false;
                }
                else if (count > <#= max #>)
                {
                    if (context.CreateError(DiagnosticSeverity.Warning))
                    {
                        result.WarningAdd($"There are too many arguments({count}) for '{kind}'. Exceeding arguments are just ignored. Required: <#= min #>.", index);
                    }
                    return false;
                }
<#  } else { #>
				if (count < <#= min #>)
                {
                    result.ErrorAdd($"There are too less arguments({count}) for '{kind}'. Required: <#= min #>~<#= max #>.", index);
                    return false;
                }
                else if (count > <#= max #>)
                {
                    if (context.CreateError(DiagnosticSeverity.Warning))
                    {
                        result.WarningAdd($"There are too many arguments({count}) for '{kind}'. Exceeding arguments are just ignored. Required: <#= min #>~<#= max #>.", index);
                    }
                    return false;
                }
<#  } #>
                break;
<# } #>
        }
        return true;
	}
<# } #>
}
