<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.TextTemplateHelper.dll" #>
<#@ import namespace="Wahren.AbstractSyntaxTree.TextTemplateHelper" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#nullable enable
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
namespace Wahren.AbstractSyntaxTree;

public enum FunctionKind : uint
{
<# foreach (var (item, min, max) in FunctionInfo.FunctionInfoArray) { #>
    <#= item #>,
<# } #>
    None = uint.MaxValue,
}

public static class FunctionKindHelper
{
    public static FunctionKind Convert(ReadOnlySpan<char> key)
    {
        if (key.Length < 3 || key.Length > 16)
        {
            return FunctionKind.None;
        }

        Span<char> span = stackalloc char[key.Length];
        key.CopyTo(span);
        for (var i = 0; i < key.Length; ++i)
        {
            if (span[i] >= 'a')
            {
                span[i] = (char)(ushort)(span[i] - 32);
            }
        }

        switch (span.Length)
        {
            case 3:
                if (span.SequenceEqual("HAS")) { return FunctionKind.has; }
                else if (span.SequenceEqual("YET")) { return FunctionKind.yet; }
                else { return FunctionKind.None; }
            case 4:
                if (span.SequenceEqual("RAND")) { return FunctionKind.rand; }
                else { return FunctionKind.None; }
        }
        ulong key4 = System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian(System.Runtime.InteropServices.MemoryMarshal.Cast<char, byte>(span));
        span = span.Slice(4);
        switch (span.Length - 1)
        {
<#
foreach (var (len, items) in FunctionInfo.FunctionInfoArray.GroupBy(x => x.Name.Length, x => x, (len, items) => (len, items.ToArray())))
{
    if (len <= 4) { continue; }
    foreach (var (item, min, max) in items)
    {
        ulong key = (ulong)(uint)item[3] - 32UL * (ulong)((ushort)item[3] >= (ushort)'a' ? 1: 0);
        key <<= 16;
        key |= (ulong)(uint)item[2] - 32UL * (ulong)((ushort)item[2] >= (ushort)'a' ? 1: 0);
        key <<= 16;
        key |= (ulong)(uint)item[1] - 32UL * (ulong)((ushort)item[1] >= (ushort)'a' ? 1: 0);
        key <<= 16;
        key |= (ulong)(uint)item[0] - 32UL * (ulong)((ushort)item[0] >= (ushort)'a' ? 1: 0);
#>
            case <#= item.Length - 5 #> when (key4 == 0x<#= key.ToString("X16") #>UL) && span.SequenceEqual("<#for(int i = 4; i < item.Length; ++i){#><#= (char)(ushort)(item[i] -32 * (item[i] >= 'a' ? 1 : 0)) #><#}#>"): return FunctionKind.<#= item #>;
<#  }
} #>
        }

        return FunctionKind.None;
    }

    public static int IsValidArgumentCount(this FunctionKind kind, int count)
    {
        if (count < 0)
        {
            return -1;
        }
        
        switch (kind)
        {
<#
foreach ((int min, IEnumerable<(int, IEnumerable<string>)> groupEnumerable) in FunctionInfo.FunctionInfoArray.GroupBy(
    item => item.Min,
    item => (item.Name, item.Max),
    (key, values) => (
        key,
        values.GroupBy(
            pair => pair.Max,
            pair => pair.Name,
            (keyInner, valuesInner) => (keyInner, valuesInner)
        )
    )))
{
    foreach (var (max, items) in groupEnumerable) {
        if (min == 0 && max == int.MaxValue) continue;
        var itemArray = items.ToArray();
        for (var index = 0; index < itemArray.Length; ++index) { #>
            case FunctionKind.<#= itemArray[index] #>: 
<#      }
        var item = itemArray[itemArray.Length - 1]; #>
<#      if (min == max && min == 0) { #>
                return count == <#= min #> ? 0 : 1;
<#      } else if (min == max) { #>
                return count == <#= min #> ? 0 : count < <#= min #> ? -1 : 1;
<#      } else if (max == int.MaxValue) { #>
                return count >= <#= min #> ? 0 : -1;
<#      } else if (min == 0) { #>
                return count <= <#= max #> ? 0 : 1;
<#      } else { #>
                return count >= <#= min #> ? (count <= <#= max #> ? 0 : 1) : -1;
<#      }
    }
} #>
            default: return 0;
        }
    }
}
