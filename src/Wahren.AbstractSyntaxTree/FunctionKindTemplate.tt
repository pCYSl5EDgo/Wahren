<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.TextTemplateHelper.dll" #>
<#@ import namespace="Wahren.AbstractSyntaxTree.TextTemplateHelper" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#nullable enable
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
namespace Wahren.AbstractSyntaxTree;

public enum FunctionKind : uint
{
<# foreach (var (item, min, max) in FunctionInfo.Normals) { #>
    <#= item #>,
<# } #>
    None = uint.MaxValue,
}

public static class FunctionKindHelper
{
    public static FunctionKind Convert(ReadOnlySpan<char> key)
    {
        if (key.Length < 3 || key.Length > 16)
        {
            return FunctionKind.None;
        }

        Span<char> span = stackalloc char[key.Length];
        key.CopyTo(span);
        for (var i = 0; i < key.Length; ++i)
        {
            if (span[i] >= 'a')
            {
                span[i] = (char)(ushort)(span[i] - 32);
            }
        }

        switch (span.Length)
        {
            case 3:
                if (span.SequenceEqual("HAS")) { return FunctionKind.has; }
                else if (span.SequenceEqual("YET")) { return FunctionKind.yet; }
                else { return FunctionKind.None; }
            case 4:
                if (span.SequenceEqual("RAND")) { return FunctionKind.rand; }
                else { return FunctionKind.None; }
        }
        ulong key4 = System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian(System.Runtime.InteropServices.MemoryMarshal.Cast<char, byte>(span));
        span = span.Slice(4);
        switch (span.Length - 1)
        {
<#
foreach (var (len, items) in FunctionInfo.Normals.GroupBy(x => x.Name.Length, x => x, (len, items) => (len, items.ToArray())))
{
    if (len <= 4) { continue; }
    foreach (var (item, min, max) in items)
    {
        ulong key = (ulong)(uint)item[3] - 32UL * (ulong)((ushort)item[3] >= (ushort)'a' ? 1: 0);
        key <<= 16;
        key |= (ulong)(uint)item[2] - 32UL * (ulong)((ushort)item[2] >= (ushort)'a' ? 1: 0);
        key <<= 16;
        key |= (ulong)(uint)item[1] - 32UL * (ulong)((ushort)item[1] >= (ushort)'a' ? 1: 0);
        key <<= 16;
        key |= (ulong)(uint)item[0] - 32UL * (ulong)((ushort)item[0] >= (ushort)'a' ? 1: 0);
#>
            case <#= item.Length - 5 #> when (key4 == 0x<#= key.ToString("X16") #>UL) && span.SequenceEqual("<#for(int i = 4; i < item.Length; ++i){#><#= (char)(ushort)(item[i] -32 * (item[i] >= 'a' ? 1 : 0)) #><#}#>"): return FunctionKind.<#= item #>;
<#  }
} #>
        }

        return FunctionKind.None;
    }
}
