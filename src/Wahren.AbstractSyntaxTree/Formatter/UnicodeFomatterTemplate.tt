<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.TextTemplateHelper.dll" #>
<#@ import namespace="Wahren.AbstractSyntaxTree.TextTemplateHelper" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#nullable enable
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using Wahren.AbstractSyntaxTree.Parser;

namespace Wahren.AbstractSyntaxTree.Formatter;

public class UnicodeFormatter : IFormatter<char>
{
    private readonly string NewLine;
    private readonly char Tab;
    private readonly int TabCount;

    private static UnicodeFormatter? _DefaultCrLf;
    private static UnicodeFormatter? _DefaultLf;

    public static UnicodeFormatter GetDefault(bool isCrLf)
    {
        if (isCrLf)
        {
            return _DefaultCrLf ??= new(' ', 4, "\r\n");
        }
        else
        {
            return _DefaultLf ??= new(' ', 4, "\n");
        }
    }

    public UnicodeFormatter(char indentChar, int indentCount, string newLine)
    {
        Tab = indentChar;
        TabCount = indentCount;

        NewLine = string.Intern(newLine);

        battle_NewLine_BracketLeft_NewLine = string.Intern("battle" + newLine + "{" + newLine);
<# foreach (var x in FormatterHelper.Pairs_NewLine) { #>
        <#= x.name #>_NewLine = string.Intern("<#= x.content #>" + NewLine);
<# } #>
<# foreach (var x in FormatterHelper.Pairs_NewLine_Pairs) { #>
        <#= x.name0 #>_NewLine_<#= x.name1 #> = string.Intern("<#= x.content0 #>" + NewLine + "<#= x.content1 #>");
<# } #>
    }

    public void Append_NewLine(ref List<char> destination, ref bool JustChangeLine)
    {
        JustChangeLine = true;
        destination.AddRange(NewLine);
    }

    public void Ensure_NewLine_Indent(ref List<char> destination, ref bool JustChangeLine, int indentCount)
    {
        if (!JustChangeLine)
        {
            destination.AddRange(NewLine);
        }

        JustChangeLine = false;
        if (indentCount <= 0)
        {
            return;
        }

        Span<char> span = stackalloc char[indentCount * TabCount];
        span.Fill(Tab);
        destination.AddRange(span);
    }

    public void Append_Indent(ref List<char> destination, ref bool JustChangeLine, int indentCount)
    {
        if (indentCount == 0)
        {
            return;
        }

        JustChangeLine = false;
        Span<char> span = stackalloc char[indentCount * TabCount];
        span.Fill(Tab);
        destination.AddRange(span);
    }

    public void Append_Copy(ref List<char> destination, ref bool JustChangeLine, ReadOnlySpan<char> singleLineSource)
    {
        destination.AddRange(singleLineSource);
    }

    public void Append_Copy(ref List<char> destination, ref bool JustChangeLine, ref DualList<char> source, ref Range range)
    {
        ref var line = ref source[range.StartInclusive.Line];
        var slice = line.AsSpan(range.StartInclusive.Offset);
        if (range.StartInclusive.Line == range.EndExclusive.Line)
        {
            slice = slice.Slice(0, (int)(range.EndExclusive.Offset - range.StartInclusive.Offset));
            destination.AddRange(slice);
            return;
        }

        var lineIndex = range.StartInclusive.Line;
        do
        {
            destination.AddRange(slice);
            Append_NewLine(ref destination, ref JustChangeLine);
            if (++lineIndex != range.EndExclusive.Line)
            {
                slice = source[lineIndex].AsSpan();
                continue;
            }

            if (range.EndExclusive.Offset == 0)
            {
                return;
            }

            slice = source[lineIndex].AsSpan(0, range.EndExclusive.Offset);
            destination.AddRange(slice);
            return;
        } while (true);
    }

    private readonly string battle_NewLine_BracketLeft_NewLine;
    public void Append_battle_NewLine_BracketLeft_NewLine(ref List<char> destination, ref bool JustChangeLine)
    {
        JustChangeLine = true;
        destination.AddRange(battle_NewLine_BracketLeft_NewLine);
    }

    public void Append_NewLine_BracketLeft_NewLine(ref List<char> destination, ref bool JustChangeLine)
    {
        JustChangeLine = true;
        destination.AddRange(battle_NewLine_BracketLeft_NewLine.AsSpan(6));
    }
<# foreach (var x in FormatterHelper.Pairs_NewLine) { #>

    private readonly string <#= x.name #>_NewLine;
    public void Append_<#= x.name #>_NewLine(ref List<char> destination, ref bool JustChangeLine)
    {
        JustChangeLine = true;
        destination.AddRange(<#= x.name #>_NewLine);
    }
<# } #>
<# foreach (var x in FormatterHelper.Pairs) { #>

    public void Append_<#= x.name #>(ref List<char> destination, ref bool JustChangeLine)
    {
        JustChangeLine = false;
        destination.AddRange("<#= x.content #>");
    }
<# } #>
<# foreach (var x in FormatterHelper.Pairs_NewLine_Pairs) { #>

    private readonly string <#= x.name0 #>_NewLine_<#= x.name1 #>;
    public void Append_<#= x.name0 #>_NewLine_<#= x.name1 #>(ref List<char> destination, ref bool JustChangeLine)
    {
        JustChangeLine = false;
        destination.AddRange(<#= x.name0 #>_NewLine_<#= x.name1 #>);
    }
<# } #>

    public bool TryFormat(ref Result result, ref List<char> destination)
    {
        ref var TokenList = ref result.TokenList;
        ref var source = ref result.Source;
        bool JustChangeLine = false;
		for (uint tokenIndex = uint.MaxValue, tokenCount = (uint)TokenList.Count; ++tokenIndex < tokenCount;)
        {
            ref var token = ref TokenList[tokenIndex];
            switch (token.Kind)
            {
                case TokenKind.Comment:
                    if (tokenIndex > 0 && TokenList[tokenIndex - 1].Kind == TokenKind.BracketRight)
                    {
                        Append_NewLine(ref destination, ref JustChangeLine);
                    }

                    Append_Copy(ref destination, ref JustChangeLine, ref source, ref token.Range);
                    continue;
<# foreach (var item in FormatterHelper.NameNodes) { #>
                case TokenKind.<#= Helper.Escape(item) #>:
                    if (tokenIndex > 0 && TokenList[tokenIndex - 1].Kind != TokenKind.Comment)
                    {
                        Append_NewLine(ref destination, ref JustChangeLine);
                    }

                    Append_<#= item #>_Space(ref destination, ref JustChangeLine);
                    break;
<# } #>
<# foreach (var item in FormatterHelper.BlockNodes) { #>
                case TokenKind.<#= item #>:
                    if (tokenIndex > 0 && TokenList[tokenIndex - 1].Kind != TokenKind.Comment)
                    {
                        Append_NewLine(ref destination, ref JustChangeLine);
                    }

                    Append_<#= item #>_NewLine_BracketLeft(ref destination, ref JustChangeLine);
                    goto CONTENTS;
<# } #>
                default:
                    return false;
            }

            if (++tokenIndex + 1 >= TokenList.Count || TokenList[tokenIndex].Kind != TokenKind.Name)
            {
                return false;
            }

            Append_Copy(ref destination, ref JustChangeLine, result.GetSpan(tokenIndex));
            if (TokenList[++tokenIndex].Kind == TokenKind.Colon)
            {
                if (++tokenIndex + 1 >= TokenList.Count || TokenList[tokenIndex].Kind != TokenKind.Super)
                {
                    return false;
                }

                Append_Space_Colon_Space(ref destination, ref JustChangeLine);
                Append_Copy(ref destination, ref JustChangeLine, result.GetSpan(tokenIndex));
            }
            else
            {
                --tokenIndex;
            }

            Append_NewLine_BracketLeft_NewLine(ref destination, ref JustChangeLine);
        CONTENTS:
            if (++tokenIndex >= TokenList.Count || TokenList[tokenIndex].Kind != TokenKind.BracketLeft)
            {
                return false;
            }
            
            if (TryFormat_Block(ref TokenList, ref source, ref destination, ref JustChangeLine, ref  tokenIndex, spaces: 1))
            {
                continue;
            }

            return false;
        }

        return true;
	}

    bool TryFormat_Block(ref List<Token> TokenList, ref DualList<char> source, ref List<char> destination, ref bool JustChangeLine, ref uint tokenIndex, int spaces)
    {
        do
        {
            if (++tokenIndex >= TokenList.Count)
            {
                return false;
            }

            ref var token = ref TokenList[tokenIndex];
            switch (token.Kind)
            {
                case TokenKind.BracketRight:
                    Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces - 1);
                    Append_BracketRight_NewLine(ref destination, ref JustChangeLine);
                    return true;
                case TokenKind.Comment:
                    Append_Copy(ref destination, ref JustChangeLine, ref source, ref token.Range);
                    continue;
                case TokenKind.DEFAULT:
                    if (TryFormatElementAssignment_DEFAULT(ref TokenList, ref source, ref destination, ref JustChangeLine, ref  token, ref tokenIndex, spaces))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.RAY:
                case TokenKind.CONSTI:
                case TokenKind.LOYAL:
                case TokenKind.MEMBER:
                case TokenKind.OFFSET:
                case TokenKind.ROAM:
                case TokenKind.TEXT:
                    if (TryFormatElementAssignment_Not_DEFAULT(ref TokenList, ref source, ref destination, ref JustChangeLine, ref  token, ref tokenIndex, spaces))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.rif:
                    Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                    Append_rif_Space_ParenLeft(ref destination, ref JustChangeLine);
                    if (TryFormat_If(ref TokenList, ref source, ref destination, ref JustChangeLine, ref  tokenIndex, spaces))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.@if:
                    Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                    Append_if_Space_ParenLeft(ref destination, ref JustChangeLine);
                    if (TryFormat_If(ref TokenList, ref source, ref destination, ref JustChangeLine, ref  tokenIndex, spaces))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.@while:
                    Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                    Append_while_Space_ParenLeft(ref destination, ref JustChangeLine);
                    if (!TryFormat_Condition(ref TokenList, ref source, ref destination, ref JustChangeLine, ref  tokenIndex, spaces))
                    {
                        return false;
                    }

                    if (!TryFormat_Block(ref TokenList, ref source, ref destination, ref JustChangeLine, ref  tokenIndex, spaces))
                    {
                        return false;
                    }
                    continue;
                case TokenKind.battle:
                    Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                    Append_battle_NewLine_BracketLeft_NewLine(ref destination, ref JustChangeLine);
                    if (TryFormat_Block(ref TokenList, ref source, ref destination, ref JustChangeLine, ref  tokenIndex, spaces))
                    {
                        continue;
                    }
                    return false;
<# foreach (var kind in new string[] { "break", "continue", "next", "return" }) { #>
                case TokenKind.<#= kind.Escape() #>:
                    Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                    Append_<#= kind #>_ParenLeft_ParenRight_NewLine(ref destination, ref JustChangeLine);
                    continue;
<# } #>
                case TokenKind.CallAction:
                    switch ((ActionKind)token.Other)
                    {
<# foreach (var (action, _, _) in CallableInfo.ActionInfoNormals) { #>
                        case ActionKind.<#= action.Escape() #>:
                            Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                            Append_<#= action #>_ParenLeft(ref destination, ref JustChangeLine);
                            break;
<# } #>
                        default:
                            Append_Copy(ref destination, ref JustChangeLine, ref source, ref token.Range);
                            break;
                    }

                    if (TryFormatCallActionArguments(ref TokenList, ref source, ref destination, ref JustChangeLine, ref  tokenIndex, spaces))
                    {
                        continue;
                    }

                    return false;
            }
        } while (true);
    }

    bool TryFormatElementAssignment_Not_DEFAULT(ref List<Token> TokenList, ref DualList<char> source, ref List<char> destination, ref bool JustChangeLine, ref Token element, ref uint tokenIndex, int spaces)
    {
        if (!TryFormatElementAssignment_DEFAULT(ref TokenList, ref source, ref destination, ref JustChangeLine, ref  element, ref tokenIndex, spaces))
        {
            return false;
        }

        do
        {
            if (++tokenIndex >= TokenList.Count)
            {
                return false;
            }

            ref var token = ref TokenList[tokenIndex];
            switch (token.Kind)
            {
                case TokenKind.Content:
                    if (token.IsFirstTokenInTheLine)
                    {
                        Append_NewLine(ref destination, ref JustChangeLine);
                        Append_Indent(ref destination, ref JustChangeLine, spaces + 1);
                    }

                    Append_Copy(ref destination, ref JustChangeLine, ref source, ref token.Range);
                    continue;
                case TokenKind.Mul:
                    Append_Space_Mul_Space(ref destination, ref JustChangeLine);
                    continue;
                case TokenKind.Semicolon:
                    if (token.IsFirstTokenInTheLine)
                    {
                        Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                    }

                    Append_Semicolon(ref destination, ref JustChangeLine);
                    return true;
                case TokenKind.Comma:
                    if (tokenIndex + 1 < TokenList.Count && TokenList[tokenIndex + 1].IsFirstTokenInTheLine)
                    {
                        Append_Comma(ref destination, ref JustChangeLine);
                    }
                    else
                    {
                        Append_Comma_Space(ref destination, ref JustChangeLine);
                    }

                    continue;
                default:
                    --tokenIndex;
                    return true;
            }
        } while (true);
    }

    bool TryFormatElementAssignment_DEFAULT(ref List<Token> TokenList, ref DualList<char> source, ref List<char> destination, ref bool JustChangeLine, ref Token element, ref uint tokenIndex, int spaces)
    {
        if (++tokenIndex + 1 >= TokenList.Count || TokenList[tokenIndex].Kind != TokenKind.Assign)
        {
            return false;
        }

        ref var content = ref TokenList[++tokenIndex];
        if (content.Kind != TokenKind.Content)
        {
            return false;
        }

        Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
        Append_Copy(ref destination, ref JustChangeLine, ref source, ref element.Range);
        if (content.IsFirstTokenInTheLine)
        {
            Append_Space_Assign(ref destination, ref JustChangeLine);
            Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces + 1);
        }
        else
        {
            Append_Space_Assign_Space(ref destination, ref JustChangeLine);
        }

        Append_Copy(ref destination, ref JustChangeLine, ref source, ref content.Range);
        return true;
    }

    bool TryFormatCallActionArguments(ref List<Token> TokenList, ref DualList<char> source, ref List<char> destination, ref bool JustChangeLine, ref uint tokenIndex, int spaces)
    {
        do
        {
            if (++tokenIndex >= TokenList.Count)
            {
                return false;
            }

            ref var token = ref TokenList[tokenIndex];
            switch (token.Kind)
            {
                case TokenKind.Content:
                    if (token.IsFirstTokenInTheLine)
                    {
                        Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces + 1);
                    }
                    Append_Copy(ref destination, ref JustChangeLine, ref source, ref token.Range);
                    continue;
                case TokenKind.Comma:
                    if (tokenIndex + 1 < TokenList.Count && TokenList[tokenIndex + 1].IsFirstTokenInTheLine)
                    {
                        Append_Comma(ref destination, ref JustChangeLine);
                    }
                    else
                    {
                        Append_Comma_Space(ref destination, ref JustChangeLine);
                    }

                    continue;
                case TokenKind.ParenRight:
                    Append_ParenRight(ref destination, ref JustChangeLine);
                    return true;
                default:
                    --tokenIndex;
                    return true;
            }
        } while (true);
    }

    bool TryFormat_If(ref List<Token> TokenList, ref DualList<char> source, ref List<char> destination, ref bool JustChangeLine, ref uint tokenIndex, int spaces)
    {
        if (!TryFormat_Condition(ref TokenList, ref source, ref destination, ref JustChangeLine, ref  tokenIndex, spaces))
        {
            return false;
        }

        if (!TryFormat_Block(ref TokenList, ref source, ref destination, ref JustChangeLine, ref  tokenIndex, spaces + 1))
        {
            return false;
        }

        if (++tokenIndex + 1 >= TokenList.Count || TokenList[tokenIndex].Kind != TokenKind.Else)
        {
            --tokenIndex;
            return true;
        }

        Append_Indent(ref destination, ref JustChangeLine, spaces);
        switch (TokenList[++tokenIndex].Kind)
        {
            case TokenKind.@if:
                Append_else_Space_if_ParenLeft(ref destination, ref JustChangeLine);
                return TryFormat_If(ref TokenList, ref source, ref destination, ref JustChangeLine, ref  tokenIndex, spaces);
            case TokenKind.rif:
                Append_else_Space_rif_ParenLeft(ref destination, ref JustChangeLine);
                return TryFormat_If(ref TokenList, ref source, ref destination, ref JustChangeLine, ref  tokenIndex, spaces);
            case TokenKind.BracketLeft:
                Append_else_NewLine(ref destination, ref JustChangeLine);
                Append_Indent(ref destination, ref JustChangeLine, spaces);
                Append_BracketLeft_NewLine(ref destination, ref JustChangeLine);
                return TryFormat_Block(ref TokenList, ref source, ref destination, ref JustChangeLine, ref  tokenIndex, spaces + 1);
            default:
                return false;
        }
    }

    bool TryFormat_Condition(ref List<Token> TokenList, ref DualList<char> source, ref List<char> destination, ref bool JustChangeLine, ref uint tokenIndex, int spaces)
    {
        do
        {
            if (++tokenIndex >= TokenList.Count)
            {
                return false;
            }

            ref var token = ref TokenList[tokenIndex];
            switch (token.Kind)
            {
                case TokenKind.BracketLeft:
                    Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                    Append_BracketLeft(ref destination, ref JustChangeLine);
                    return true;
<# foreach (var x in FormatterHelper.Operators) { #>
                case TokenKind.<#= x.name #>:
                    Append_Space_<#= x.name #>_Space(ref destination, ref JustChangeLine);
                    continue;
<# }#>
                case TokenKind.ParenLeft:
                    Append_ParenLeft(ref destination, ref JustChangeLine);
                    continue;
                case TokenKind.ParenRight:
                    Append_ParenRight(ref destination, ref JustChangeLine);
                    continue;
                case TokenKind.Comma:
                    Append_Comma_Space(ref destination, ref JustChangeLine);
                    continue;
                case TokenKind.CallFunction:
                    switch ((FunctionKind)token.Other)
                    {
<# foreach (var (name, _, _) in CallableInfo.FunctionInfoNormals) { #>
                        case FunctionKind.<#= name.Escape() #>:
                            Append_<#= name #>_ParenLeft(ref destination, ref JustChangeLine);
                            continue;
<# } #>
                    }

                    goto default;
                default:
                    Append_Copy(ref destination, ref JustChangeLine, ref source, ref token.Range);
                    continue;
            }
        } while (true);
    }
}
