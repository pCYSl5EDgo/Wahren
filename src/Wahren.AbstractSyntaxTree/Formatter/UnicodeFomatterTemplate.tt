<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.TextTemplateHelper.dll" #>
<#@ import namespace="Wahren.AbstractSyntaxTree.TextTemplateHelper" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#nullable enable
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
namespace Wahren.AbstractSyntaxTree.Parser;

public partial struct Result : ISpanFormattable
{
<# foreach ((string suffix, string chars, int count) in new (string, string, int)[] { ("CrLf", "\\r\\n", 2), ("Lf", "\\n", 1) }) { #>
    private bool TryFormatBeautify<#= suffix #>(ref FormatterContext context)
    {
        Span<char> span;
        for (uint tokenIndex = uint.MaxValue, tokenCount = (uint)TokenList.Count; ++tokenIndex < tokenCount;)
        {
            ref var token = ref TokenList[tokenIndex];
            switch (token.Kind)
            {
                case TokenKind.Comment:
                    if (tokenIndex > 0 && TokenList[tokenIndex - 1].Kind == TokenKind.BracketRight)
                    {
                        if (!Try_<#= suffix #>(ref context))
                        {
                            return false;
                        }
                    }

                    TryCopy_<#= suffix #>(ref token.Range, ref context);
                    continue;
<# foreach (var item in new string[] {
"spot",
"unit",
"race",    
"class",  
"field",   
"skill",   
"power",   
"voice",   
"object", 
"dungeon", 
"movetype",
"skillset",
"story",   
"fight",   
"world",   
"event",  
"scenario",
}) { #>
                case TokenKind.<#= Helper.Escape(item) #>:
                    if (tokenIndex > 0 && TokenList[tokenIndex - 1].Kind != TokenKind.Comment)
                    {
                        if (!Try_<#= suffix #>(ref context))
                        {
                            return false;
                        }
                    }

                    if (!"<#= item #> ".TryCopyTo(context.Destination))
                    {
                        return false;
                    }

                    context.Destination = context.Destination.Slice(<#= 1 + item.Length #>);
                    context.Written += <#= 1 + item.Length #>;
                    context.JustChangeLine = false;
                    break;
<# } 
foreach (var item in new string[] {
    "context",
    "workspace",
    "attribute",
    "sound",
    "detail",
}) { #>
                case TokenKind.<#= item #>:
                    if (tokenIndex > 0 && TokenList[tokenIndex - 1].Kind != TokenKind.Comment)
                    {
                        if (!Try_<#= suffix #>(ref context))
                        {
                            return false;
                        }
                    }

                    if (!"<#= item #><#= chars #>{".TryCopyTo(context.Destination))
                    {
                        return false;
                    }

                    context.Destination = context.Destination.Slice(<#= count + 1 + item.Length #>);
                    context.Written += <#= count + 1 + item.Length #>;
                    context.JustChangeLine = false;
                    goto CONTENTS;
<# } #>
                default:
                    context.FormatFail = true;
                    return false;
            }

            if (++tokenIndex + 1 >= TokenList.Count)
            {
                context.FormatFail = true;
                return false;
            }

            if (TokenList[tokenIndex].Kind != TokenKind.Name)
            {
                context.FormatFail = true;
                return false;
            }
            
            span = GetSpan(tokenIndex);
            if (!span.TryCopyTo(context.Destination))
            {
                return false;
            }

            context.Destination = context.Destination.Slice(span.Length);
            context.Written += span.Length;
            if (TokenList[++tokenIndex].Kind == TokenKind.Colon)
            {
                if (++tokenIndex + 1 >= TokenList.Count)
                {
                    context.FormatFail = true;
                    return false;
                }

                if (TokenList[tokenIndex].Kind != TokenKind.Super)
                {
                    context.FormatFail = true;
                    return false;
                }

                if (!" : ".TryCopyTo(context.Destination))
                {
                    return false;
                }

                context.Destination = context.Destination.Slice(3);
                span = GetSpan(tokenIndex);
                if (!span.TryCopyTo(context.Destination))
                {
                    return false;
                }

                context.Destination = context.Destination.Slice(span.Length);
                context.Written += span.Length + 3;
            }
            else
            {
                --tokenIndex;
            }

            if (!"<#= chars #>{<#= chars #>".TryCopyTo(context.Destination))
            {
                return false;
            }

            context.Destination = context.Destination.Slice(<#= count * 2 + 1 #>);
            context.Written += <#= count * 2 + 1 #>;
            context.JustChangeLine = true;
        CONTENTS:
            if (++tokenIndex >= TokenList.Count)
            {
                context.FormatFail = true;
                return false;
            }

            if (TokenList[tokenIndex].Kind != TokenKind.BracketLeft)
            {
                context.FormatFail = true;
                return false;
            }

            if (TryFormatContents_<#= suffix #>(ref tokenIndex, ref context))
            {
                continue;
            }

            return false;
        }

        return true;
    }

    private bool TryCopy_<#= suffix #>(ref Range range, ref FormatterContext context)
    {
        ref var line = ref Source[range.StartInclusive.Line];
        var slice = line.AsSpan(range.StartInclusive.Offset);
        if (range.StartInclusive.Line == range.EndExclusive.Line)
        {
            slice = slice.Slice(0, (int)(range.EndExclusive.Offset - range.StartInclusive.Offset));
            if (slice.TryCopyTo(context.Destination))
            {
                context.Destination = context.Destination.Slice(slice.Length);
                context.Written += slice.Length;
                context.JustChangeLine = false;
                return true;
            }
            else
            {
                return false;
            }
        }

        var lineIndex = range.StartInclusive.Line;
        do
        {
            if (!slice.TryCopyTo(context.Destination))
            {
                return false;
            }

            context.Destination = context.Destination.Slice(slice.Length);
            context.Written += slice.Length;

            if (!Try_<#= suffix #>(ref context))
            {
                return false;
            }

            if (++lineIndex != range.EndExclusive.Line)
            {
                slice = Source[lineIndex].AsSpan();
                continue;
            }

            if (range.EndExclusive.Offset == 0)
            {
                return true;
            }

            slice = Source[lineIndex].AsSpan(0, range.EndExclusive.Offset);
            if (!slice.TryCopyTo(context.Destination))
            {
                return false;
            }

            context.Destination = context.Destination.Slice(slice.Length);
            context.Written += slice.Length;
            context.JustChangeLine = false;
            return true;
        } while (true);
    }

    private bool TryFormat_AsIs_<#= suffix #>(ref FormatterContext context)
    {
        context.Written = 0;
        for (uint lineIndex = 0, count = (uint)Source.Count; lineIndex != count; lineIndex++)
        {
            ref var line = ref Source[lineIndex];
            if (lineIndex != 0 && !Try_<#= suffix #>(ref context))
            {
                return false;
            }

            if (line.AsSpan().TryCopyTo(context.Destination))
            {
                context.Destination = context.Destination.Slice(line.Count);
                context.Written += line.Count;
            }
            else
            {
                return false;
            }
        }

        return true;
    }

    private bool TryFormat_Block_<#= suffix #>(ref uint tokenIndex, ref FormatterContext context, int spaces)
    {
        do
        {
            if (++tokenIndex >= TokenList.Count)
            {
                context.FormatFail = true;
                return false;
            }

            ref var element = ref TokenList[tokenIndex];
            switch (element.Kind)
            {
                case TokenKind.BracketRight:
                    if (!context.JustChangeLine && !Try_<#= suffix #>(ref context))
                    {
                        return false;
                    }
                    
                    if (!FillSpaces(ref context, spaces - 4))
                    {
                        return false;
                    }

                    return Try_BracketRight_<#= suffix #>(ref context);
                case TokenKind.Comment:
                    if (TryCopy_<#= suffix #>(ref element.Range, ref context))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.DEFAULT:
                    if (TryFormatElementAssignment_<#= suffix #>_DEFAULT(ref element, ref tokenIndex, ref context, spaces))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.RAY:
                case TokenKind.CONSTI:
                case TokenKind.LOYAL:
                case TokenKind.MEMBER:
                case TokenKind.OFFSET:
                case TokenKind.ROAM:
                case TokenKind.TEXT:
                    if (TryFormatElementAssignment_<#= suffix #>_Not_DEFAULT(ref element, ref tokenIndex, ref context, spaces))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.rif:
                    if (!context.JustChangeLine && !Try_<#= suffix #>(ref context))
                    {
                        return false;
                    }

                    if (!FillSpaces(ref context, spaces))
                    {
                        return false;
                    }
                    
                    if (!"rif (".TryCopyTo(context.Destination))
                    {
                        return false;
                    }

                    context.Destination = context.Destination.Slice(5);
                    context.Written += 5;
                    context.JustChangeLine = false;
                    if (TryFormat_If_<#= suffix #>(ref tokenIndex, ref context, spaces))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.@if:
                    if (!context.JustChangeLine && !Try_<#= suffix #>(ref context))
                    {
                        return false;
                    }

                    if (!FillSpaces(ref context, spaces))
                    {
                        return false;
                    }
                    
                    if (!"if (".TryCopyTo(context.Destination))
                    {
                        return false;
                    }

                    context.Destination = context.Destination.Slice(4);
                    context.Written += 4;
                    context.JustChangeLine = false;
                    if (TryFormat_If_<#= suffix #>(ref tokenIndex, ref context, spaces))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.@while:
                    if ((!context.JustChangeLine && !Try_<#= suffix #>(ref context)) || !FillSpaces(ref context, spaces) || !"while (".TryCopyTo(context.Destination))
                    {
                        return false;
                    }
                    context.Destination = context.Destination.Slice(7);
                    context.Written += 7;
                    context.JustChangeLine = false;
                    if (!TryFormat_Condition_<#= suffix #>(ref tokenIndex, ref context, spaces) || !TryFormat_Block_<#= suffix #>(ref tokenIndex, ref context, spaces))
                    {
                        return false;
                    }
                    continue;
                case TokenKind.battle:
                    if ((!context.JustChangeLine && !Try_<#= suffix #>(ref context)) || !FillSpaces(ref context, spaces) || !"battle<#= chars #>".TryCopyTo(context.Destination) || !FillSpaces(ref context, spaces))
                    {
                        return false;
                    }
                    context.Destination = context.Destination.Slice(<#= 6 + count #>);
                    if (!"{<#= chars #>".TryCopyTo(context.Destination))
                    {
                        return false;
                    }
                    context.Destination = context.Destination.Slice(<#= 1 + count #>);
                    context.Written += <#= 7 + count * 2 #>;
                    context.JustChangeLine = true;
                    if (TryFormat_Block_<#= suffix #>(ref tokenIndex, ref context, spaces))
                    {
                        continue;
                    }
                    return false;
<# foreach (var kind in new string[] { "break", "continue", "next", "return" }) { #>
                case TokenKind.<#= kind.Escape() #>:
                    if ((!context.JustChangeLine && !Try_<#= suffix #>(ref context)) || !FillSpaces(ref context, spaces) || !"<#= kind #>()<#= chars #>".TryCopyTo(context.Destination))
                    {
                        return false;
                    }
                    context.Destination = context.Destination.Slice(<#= kind.Length + 2 + count #>);
                    context.Written += <#= kind.Length + 2 + count #>;
                    context.JustChangeLine = true;
                    continue;
<# } #>
                case TokenKind.CallAction:
                    switch ((ActionKind)element.Other)
                    {
<# foreach (var (action, _, _) in ActionInfo.Normals) { #>
                        case ActionKind.<#= action.Escape() #>:
                            if ((!context.JustChangeLine && !Try_<#= suffix #>(ref context)) || !FillSpaces(ref context, spaces) || !"<#= action #>(".TryCopyTo(context.Destination))
                            {
                                return false;
                            }
                            context.Destination = context.Destination.Slice(<#= action.Length + 1 #>);
                            context.Written += <#= action.Length + 1 #>;
                            context.JustChangeLine = false;
                            break;
<# } #>
                        default:
                            if (!TryCopy_<#= suffix #>(ref element.Range, ref context))
                            {
                                return false;
                            }
                            break;
                    }

                    if (TryFormatCallActionArguments_<#= suffix #>(ref tokenIndex, ref context, spaces))
                    {
                        continue;
                    }

                    return false;
            }
        } while (true);
    }

    private bool TryFormat_If_<#= suffix #>(ref uint tokenIndex, ref FormatterContext context, int spaces)
    {
        if (!TryFormat_Condition_<#= suffix #>(ref tokenIndex, ref context, spaces))
        {
            return false;
        }

        if (!TryFormat_Block_<#= suffix #>(ref tokenIndex, ref context, spaces + 4))
        {
            return false;
        }

        if (++tokenIndex + 1 >= TokenList.Count || TokenList[tokenIndex].Kind != TokenKind.Else)
        {
            --tokenIndex;
            return true;
        }

        if (!FillSpaces(ref context, spaces))
        {
            return false;
        }

        switch (TokenList[++tokenIndex].Kind)
        {
            case TokenKind.@if:
                if (!Try_Else_If(ref context))
                {
                    return false;
                }

                return TryFormat_If_<#= suffix #>(ref tokenIndex, ref context, spaces);
            case TokenKind.rif:
                if (!Try_Else_Rif(ref context))
                {
                    return false;
                }
                
                return TryFormat_If_<#= suffix #>(ref tokenIndex, ref context, spaces);
            case TokenKind.BracketLeft:
                if (!Try_Else_<#= suffix #>(ref context))
                {
                    return false;
                }
                
                if (!FillSpaces(ref context, spaces))
                {
                    return false;
                }

                if (!Try_BracketLeft_<#= suffix #>(ref context))
                {
                    return false;
                }

                return TryFormat_Block_<#= suffix #>(ref tokenIndex, ref context, spaces + 4);
            default:
                context.FormatFail = true;
                return false;
        }
    }

    /// <summary>
    /// Already write structure Kind (and : super) and Bracket Left.
    /// </summary>
    private bool TryFormatContents_<#= suffix #>(ref uint tokenIndex, ref FormatterContext context)
    {
        do
        {
            if (++tokenIndex >= TokenList.Count)
            {
                context.FormatFail = true;
                return false;
            }

            ref var element = ref TokenList[tokenIndex];
            switch (element.Kind)
            {
                case TokenKind.BracketRight:
                    if (context.JustChangeLine)
                    {
                        return Try_BracketRight_<#= suffix #>(ref context);
                    }
                    
                    if (!"<#= chars #>}<#= chars #>".TryCopyTo(context.Destination))
                    {
                        return false;
                    }

                    context.Destination = context.Destination.Slice(<#= count * 2 + 1 #>);
                    context.Written += <#= count * 2 + 1 #>;
                    context.JustChangeLine = true;
                    return true;
                case TokenKind.Comment:
                    if (TryCopy_<#= suffix #>(ref element.Range, ref context))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.DEFAULT:
                    if (TryFormatElementAssignment_<#= suffix #>_DEFAULT(ref element, ref tokenIndex, ref context))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.RAY:
                case TokenKind.CONSTI:
                case TokenKind.LOYAL:
                case TokenKind.MEMBER:
                case TokenKind.OFFSET:
                case TokenKind.ROAM:
                case TokenKind.TEXT:
                    if (TryFormatElementAssignment_<#= suffix #>_Not_DEFAULT(ref element, ref tokenIndex, ref context))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.rif:
                    if (context.JustChangeLine)
                    {
                        if (!"    rif (".TryCopyTo(context.Destination))
                        {
                            return false;
                        }

                        context.Destination = context.Destination.Slice(9);
                        context.Written += 9;
                    }
                    else
                    {
                        if (!"<#= chars #>    rif (".TryCopyTo(context.Destination))
                        {
                            return false;
                        }

                        context.Destination = context.Destination.Slice(<#= 9 + count #>);
                        context.Written += <#= 9 + count #>;
                    }
                    
                    context.JustChangeLine = false;
                    if (TryFormat_If_<#= suffix #>(ref tokenIndex, ref context, spaces: 4))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.@if:
                    if (context.JustChangeLine)
                    {
                        if (!"    if (".TryCopyTo(context.Destination))
                        {
                            return false;
                        }

                        context.Destination = context.Destination.Slice(8);
                        context.Written += 8;
                    }
                    else
                    {
                        if (!"<#= chars #>    if (".TryCopyTo(context.Destination))
                        {
                            return false;
                        }

                        context.Destination = context.Destination.Slice(<#= 8 + count #>);
                        context.Written += <#= 8 + count #>;
                    }
                    
                    context.JustChangeLine = false;
                    if (TryFormat_If_<#= suffix #>(ref tokenIndex, ref context, spaces: 4))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.@while:
                    if (context.JustChangeLine)
                    {
                        if (!"    while (".TryCopyTo(context.Destination))
                        {
                            return false;
                        }

                        context.Destination = context.Destination.Slice(11);
                        context.Written += 11;
                    }
                    else
                    {
                        if (!"<#= chars #>    while (".TryCopyTo(context.Destination))
                        {
                            return false;
                        }

                        context.Destination = context.Destination.Slice(<#= 11 + count #>);
                        context.Written += <#= 11 + count #>;
                    }
                    
                    context.JustChangeLine = false;
                    if (!TryFormat_Condition_<#= suffix #>(ref tokenIndex, ref context, spaces: 4))
                    {
                        return false;
                    }
                    
                    if (TryFormat_Block_<#= suffix #>(ref tokenIndex, ref context, spaces: 8))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.battle:
                    if (context.JustChangeLine)
                    {
                        if (!"    battle<#= chars #>    {<#= chars #>".TryCopyTo(context.Destination))
                        {
                            return false;
                        }

                        context.Destination = context.Destination.Slice(<#= 15 + count * 2 #>);
                        context.Written += <#= 15 + count * 2 #>;
                    }
                    else
                    {
                        if (!"<#= chars #>    battle<#= chars #>    {<#= chars #>".TryCopyTo(context.Destination))
                        {
                            return false;
                        }

                        context.Destination = context.Destination.Slice(<#= 15 + count * 3 #>);
                        context.Written += <#= 15 + count * 3 #>;
                    }
                    
                    context.JustChangeLine = true;
                    if (TryFormat_Block_<#= suffix #>(ref tokenIndex, ref context, spaces: 4))
                    {
                        continue;
                    }

                    return false;
<# foreach (var kind in new string[] { "break", "continue", "next", "return" }) { #>
                case TokenKind.<#= kind.Escape() #>:
                    if (context.JustChangeLine)
                    {
                        if (!"    <#= kind #>()<#= chars #>".TryCopyTo(context.Destination))
                        {
                            return false;
                        }

                        context.Destination = context.Destination.Slice(<#= kind.Length + 6 + count #>);
                        context.Written += <#= kind.Length + 6 + count #>;
                    }
                    else
                    {
                        if (!"<#= chars #>    <#= kind #>()<#= chars #>".TryCopyTo(context.Destination))
                        {
                            return false;
                        }

                        context.Destination = context.Destination.Slice(<#= kind.Length + 6 + count * 2 #>);
                        context.Written += <#= kind.Length + 6 + count * 2 #>;
                    }
                    
                    context.JustChangeLine = true;
                    continue;
<# } #>
                case TokenKind.CallAction:
                    switch ((ActionKind)element.Other)
                    {
<# foreach (var (action, _, _) in ActionInfo.Normals) { #>
                        case ActionKind.<#= action.Escape() #>:
                            if (context.JustChangeLine)
                            {
                                if (!"    <#= action #>(".TryCopyTo(context.Destination))
                                {
                                    return false;
                                }

                                context.Destination = context.Destination.Slice(<#= action.Length + 5 #>);
                                context.Written += <#= action.Length + 5 #>;
                            }
                            else
                            {
                                if (!"<#= chars #>    <#= action #>(".TryCopyTo(context.Destination))
                                {
                                    return false;
                                }

                                context.Destination = context.Destination.Slice(<#= count + action.Length + 5 #>);
                                context.Written += <#= count + action.Length + 5 #>;
                            }

                            context.JustChangeLine = false;
                            break;
<# } #>
                        default:
                            if (!TryCopy_<#= suffix #>(ref element.Range, ref context))
                            {
                                return false;
                            }
                            break;
                    }

                    if (TryFormatCallActionArguments_<#= suffix #>(ref tokenIndex, ref context, spaces: 4))
                    {
                        continue;
                    }

                    return false;
            }
        } while (true);
    }

    private bool TryFormat_Condition_<#= suffix #>(ref uint tokenIndex, ref FormatterContext context, int spaces)
    {
        do
        {
            if (++tokenIndex >= TokenList.Count)
            {
                context.FormatFail = true;
                return false;
            }

            ref var token = ref TokenList[tokenIndex];
            switch (token.Kind)
            {
                case TokenKind.BracketLeft:
                    return Try_<#= suffix #>(ref context) && FillSpaces(ref context, spaces) && Try_BracketLeft_<#= suffix #>(ref context);
<# foreach (var (item, content) in new (string, string)[] {
("Mul", " * "),
("Div", " / "),
("Add", " + "),
("Sub", " - "),
("Percent", " % "),
("And", " && "),
("Or", " || "),
("CompareEqual", " == "),
("CompareNotEqual", " != "),
("CompareGreaterThan", " > "),
("CompareGreaterThanOrEqualTo", " >= "),
("CompareLessThan", " < "),
("CompareLessThanOrEqualTo", " <= "),
}) { #>
                case TokenKind.<#= item #>:
                    if (!"<#= content #>".TryCopyTo(context.Destination))
                    {
                        return false;
                    }

                    context.Destination = context.Destination.Slice(<#= content.Length #>);
                    context.Written += <#= content.Length #>;
                    context.JustChangeLine = false;
                    continue;
<# }#>
                case TokenKind.ParenLeft:
                    if (context.Destination.IsEmpty)
                    {
                        return false;
                    }
                    context.Destination[0] = '(';
                    context.Destination = context.Destination.Slice(1);
                    context.Written++;
                    context.JustChangeLine = false;
                    continue;
                case TokenKind.ParenRight:
                    if (context.Destination.IsEmpty)
                    {
                        return false;
                    }
                    context.Destination[0] = ')';
                    context.Destination = context.Destination.Slice(1);
                    context.Written++;
                    context.JustChangeLine = false;
                    continue;
                case TokenKind.Comma:
                    if (Try_Comma_Space(ref context))
                    {
                        continue;
                    }
                    return false;
                case TokenKind.CallFunction:
                    switch ((FunctionKind)token.Other)
                    {
<# foreach (var (name, _, _) in FunctionInfo.FunctionInfoArray) { #>
                        case FunctionKind.<#= name.Escape() #>:
                            if (!"<#= name #>(".TryCopyTo(context.Destination))
                            {
                                return false;
                            }
                            context.Destination = context.Destination.Slice(<#= name.Length + 1 #>);
                            context.Written += <#= name.Length + 1 #>;
                            context.JustChangeLine = false;
                            continue;
<# } #>
                    }

                    goto default;
                default:
                    if (TryCopy_<#= suffix #>(ref token.Range, ref context))
                    {
                        continue;
                    }
                    return false;
            }
        } while (true);
    }

    private bool TryFormatElementAssignment_<#= suffix #>_Not_DEFAULT(ref Token element, ref uint tokenIndex, ref FormatterContext context)
    {
        if (!TryFormatElementAssignment_<#= suffix #>_DEFAULT(ref element, ref tokenIndex, ref context))
        {
            return false;
        }

        do
        {
            if (++tokenIndex >= TokenList.Count)
            {
                context.FormatFail = true;
                return false;
            }

            ref var token = ref TokenList[tokenIndex];
            switch (token.Kind)
            {
                case TokenKind.Content:
                    if (token.IsFirstTokenInTheLine)
                    {
                        if (!"<#= chars #>        ".TryCopyTo(context.Destination))
                        {
                            return false;
                        }

                        context.Destination = context.Destination.Slice(<#= count + 8 #>);
                        context.Written += <#= count + 8 #>;
                        context.JustChangeLine = false;
                    }

                    if (TryCopy_<#= suffix #>(ref token.Range, ref context))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.Mul:
                    if (!" * ".TryCopyTo(context.Destination))
                    {
                        return false;
                    }

                    context.Destination = context.Destination.Slice(3);
                    context.Written += 3;
                    context.JustChangeLine = false;
                    continue;
                case TokenKind.Semicolon:
                    if (token.IsFirstTokenInTheLine)
                    {
                        if (context.JustChangeLine)
                        {
                            if (context.Destination.Length < 4)
                            {
                                return false;
                            }
                            context.Destination.Slice(0, 4).Fill(' ');
                            context.Destination = context.Destination.Slice(4);
                            context.Written += 4;
                        }
                        else
                        {
                            if (!"<#= chars #>    ".TryCopyTo(context.Destination))
                            {
                                return false;
                            }
                            context.Destination = context.Destination.Slice(<#= count + 4 #>);
                            context.Written += <#= count + 4 #>;
                        }   
                        context.JustChangeLine = false;
                    }
                    return Try_Semicolon(ref context);
                case TokenKind.Comma:
                    if (tokenIndex + 1 < TokenList.Count && TokenList[tokenIndex + 1].IsFirstTokenInTheLine)
                    {
                        if (!Try_Comma(ref context))
                        {
                            return false;
                        }
                    }
                    else
                    {
                        if (!Try_Comma_Space(ref context))
                        {
                            return false;
                        }
                    }

                    continue;
                default:
                    --tokenIndex;
                    return true;
            }
        } while (true);
    }

    private bool TryFormatElementAssignment_<#= suffix #>_Not_DEFAULT(ref Token element, ref uint tokenIndex, ref FormatterContext context, int spaces)
    {
        if (!TryFormatElementAssignment_<#= suffix #>_DEFAULT(ref element, ref tokenIndex, ref context, spaces))
        {
            return false;
        }

        do
        {
            if (++tokenIndex >= TokenList.Count)
            {
                context.FormatFail = true;
                return false;
            }

            ref var token = ref TokenList[tokenIndex];
            switch (token.Kind)
            {
                case TokenKind.Content:
                    if (token.IsFirstTokenInTheLine)
                    {
                        if (!Try_<#= suffix #>(ref context))
                        {
                            return false;
                        }

                        if (!FillSpaces(ref context, spaces + 4))
                        {
                            return false;
                        }
                    }

                    if (TryCopy_<#= suffix #>(ref token.Range, ref context))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.Mul:
                    if (!" * ".TryCopyTo(context.Destination))
                    {
                        return false;
                    }

                    context.Destination = context.Destination.Slice(3);
                    context.Written += 3;
                    context.JustChangeLine = false;
                    continue;
                case TokenKind.Semicolon:
                    if (token.IsFirstTokenInTheLine)
                    {
                        if (!context.JustChangeLine)
                        {
                            if (!Try_<#= suffix #>(ref context))
                            {
                                return false;
                            }
                        }

                        if (!FillSpaces(ref context, spaces))
                        {
                            return false;
                        }
                    }

                    return Try_Semicolon(ref context);
                case TokenKind.Comma:
                    if (tokenIndex + 1 < TokenList.Count && TokenList[tokenIndex + 1].IsFirstTokenInTheLine)
                    {
                        if (!Try_Comma(ref context))
                        {
                            return false;
                        }
                    }
                    else
                    {
                        if (!Try_Comma_Space(ref context))
                        {
                            return false;
                        }
                    }

                    continue;
                default:
                    --tokenIndex;
                    return true;
            }
        } while (true);
    }

    private bool TryFormatElementAssignment_<#= suffix #>_DEFAULT(ref Token element, ref uint tokenIndex, ref FormatterContext context)
    {
        if (++tokenIndex + 1 >= TokenList.Count || TokenList[tokenIndex].Kind != TokenKind.Assign)
        {
            context.FormatFail = true;
            return false;
        }

        ref var content = ref TokenList[++tokenIndex];
        if (content.Kind != TokenKind.Content)
        {
            context.FormatFail = true;
            return false;
        }

        if (element.IsFirstTokenInTheLine && context.JustChangeLine)
        {
            if (context.Destination.Length < 4)
            {
                return false;
            }
            context.Destination.Slice(0, 4).Fill(' ');
            context.Destination = context.Destination.Slice(4);
            context.Written += 4;
        }
        else
        {
            if (!"<#= chars #>    ".TryCopyTo(context.Destination))
            {
                return false;
            }
            context.Destination = context.Destination.Slice(<#= count + 4 #>);
            context.Written += <#= count + 4 #>;
        }
        
        context.JustChangeLine = false;
        if (!TryCopy_<#= suffix #>(ref element.Range, ref context))
        {
            return false;
        }

        if (content.IsFirstTokenInTheLine)
        {
            if (!Try_Space_Assign_<#= suffix #>_Tab2(ref context))
            {
                return false;
            }
        }
        else
        {
            if (!" = ".TryCopyTo(context.Destination))
            {
                return false;
            }

            context.Destination = context.Destination.Slice(3);
            context.Written += 3;
            context.JustChangeLine = false;
        }

        return TryCopy_<#= suffix #>(ref content.Range, ref context);
    }

    private bool TryFormatElementAssignment_<#= suffix #>_DEFAULT(ref Token element, ref uint tokenIndex, ref FormatterContext context, int spaces)
    {
        if (++tokenIndex + 1 >= TokenList.Count || TokenList[tokenIndex].Kind != TokenKind.Assign)
        {
            context.FormatFail = true;
            return false;
        }

        ref var content = ref TokenList[++tokenIndex];
        if (content.Kind != TokenKind.Content)
        {
            context.FormatFail = true;
            return false;
        }

        if ((!element.IsFirstTokenInTheLine || !context.JustChangeLine) && !Try_<#= suffix #>(ref context))
        {
            return false;
        }

        if (!FillSpaces(ref context, spaces))
        {
            return false;
        }

        if (!TryCopy_<#= suffix #>(ref element.Range, ref context))
        {
            return false;
        }

        if (content.IsFirstTokenInTheLine)
        {
            if (!Try_Space_Assign_<#= suffix #>(ref context))
            {
                return false;
            }

            if (!FillSpaces(ref context, spaces + 4))
            {
                return false;
            }
        }
        else
        {
            if (!" = ".TryCopyTo(context.Destination))
            {
                return false;
            }

            context.Destination = context.Destination.Slice(3);
            context.Written += 3;
            context.JustChangeLine = false;
        }

        return TryCopy_<#= suffix #>(ref content.Range, ref context);
    }

    private bool TryFormatCallActionArguments_<#= suffix #>(ref uint tokenIndex, ref FormatterContext context, int spaces)
    {
        do
        {
            if (++tokenIndex >= TokenList.Count)
            {
                context.FormatFail = true;
                return false;
            }

            ref var token = ref TokenList[tokenIndex];
            switch (token.Kind)
            {
                case TokenKind.Content:
                    if (token.IsFirstTokenInTheLine && !Try_<#= suffix #>(ref context) && !FillSpaces(ref context, spaces + 4))
                    {
                        return false;
                    }

                    if (TryCopy_<#= suffix #>(ref token.Range, ref context))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.Comma:
                    if (tokenIndex + 1 < TokenList.Count && TokenList[tokenIndex + 1].IsFirstTokenInTheLine)
                    {
                        if (!Try_Comma(ref context))
                        {
                            return false;
                        }
                    }
                    else
                    {
                        if (!Try_Comma_Space(ref context))
                        {
                            return false;
                        }
                    }

                    continue;
                case TokenKind.ParenRight:
                    return Try_ParenRight_<#= suffix #>(ref context);
                default:
                    --tokenIndex;
                    return true;
            }
        } while (true);
    }

<# } #>
}
