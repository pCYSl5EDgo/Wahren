<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.TextTemplateHelper.dll" #>
<#@ import namespace="Wahren.AbstractSyntaxTree.TextTemplateHelper" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#nullable enable
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using Wahren.AbstractSyntaxTree.Parser;

namespace Wahren.AbstractSyntaxTree.Formatter;

public class BinaryFormatter : IFormatter<byte>
{
    private static BinaryFormatter? _Default_Utf16Le_CrLf;
    private static BinaryFormatter? _Default_Utf16Le_Lf;
    private static BinaryFormatter? _Default_Cp932_CrLf;
    private static BinaryFormatter? _Default_Cp932_Lf;

    public static BinaryFormatter GetDefault_Utf16Le(bool isCrLf)
    {
        if (isCrLf)
        {
            return _Default_Utf16Le_CrLf ??= new(System.Text.Encoding.Unicode, ' ', 4, "\r\n");
        }
        else
        {
            return _Default_Utf16Le_Lf ??= new(System.Text.Encoding.Unicode, ' ', 4, "\n");
        }
    }

    public static BinaryFormatter GetDefault_Cp932(bool isCrLf)
    {
        if (isCrLf)
        {
            return _Default_Cp932_CrLf ??= new(System.Text.Encoding.GetEncoding(932), ' ', 4, "\r\n");
        }
        else
        {
            return _Default_Cp932_Lf ??= new(System.Text.Encoding.GetEncoding(932), ' ', 4, "\n");
        }
    }

    private readonly List<byte> registeredBytes;
    private readonly List<byte>.AddConverter<char> Converter;
    private readonly List<byte>.AddConverterAssumption Assumption;

    private readonly uint NewLineCount;
    private readonly uint TabOffset;
    private readonly uint TabCount;

<# foreach (var x in FormatterHelper.Pairs_NewLine) { #>
    private readonly uint <#= x.name #>_NewLine_Offset;
    private readonly uint <#= x.name #>_NewLine_Count;
<# } #>
<# foreach (var x in FormatterHelper.Pairs) { #>
    private readonly uint <#= x.name #>_Offset;
    private readonly uint <#= x.name #>_Count;
<# } #>
<# foreach (var x in FormatterHelper.Pairs_NewLine_Pairs) { #>
    private readonly uint <#= x.name0 #>_NewLine_<#= x.name1 #>_Offset;
    private readonly uint <#= x.name0 #>_NewLine_<#= x.name1 #>_Count;
<# } #>
    private readonly uint battle_NewLine_BracketLeft_NewLine_Offset;
    private readonly uint battle_NewLine_BracketLeft_NewLine_Count;
    private readonly uint NewLine_BracketLeft_NewLine_Offset;
    private readonly uint NewLine_BracketLeft_NewLine_Count;

    public void Dispose()
    {
        registeredBytes.Dispose();
    }

    public BinaryFormatter(System.Text.Encoding encoding, char indentChar, int indentCount, ReadOnlySpan<char> newLine)
    {
        Converter = new(encoding.GetBytes);
        Assumption = new(encoding.GetMaxByteCount);
        registeredBytes = new();
        uint accum = 0;

        registeredBytes.AddRangeConversion(Converter, Assumption, newLine);
        NewLineCount = (uint)registeredBytes.Count;
        accum = (uint)registeredBytes.Count;

        {
            Span<char> indent = stackalloc char[indentCount];
            indent.Fill(indentChar);
            registeredBytes.AddRangeConversion(Converter, Assumption, indent);
            TabOffset = accum;
            TabCount = (uint)registeredBytes.Count - accum;
            accum = (uint)registeredBytes.Count;
        }

        var convertedNewLine = registeredBytes.AsSpan(0, NewLineCount);

        registeredBytes.AddRangeConversion(Converter, Assumption, "battle");
        registeredBytes.AddRange(convertedNewLine);
        registeredBytes.AddRangeConversion(Converter, Assumption, "{");
        registeredBytes.AddRange(convertedNewLine);
        battle_NewLine_BracketLeft_NewLine_Offset = accum;
        battle_NewLine_BracketLeft_NewLine_Count = (uint)registeredBytes.Count - accum;
        accum = (uint)registeredBytes.Count;

        registeredBytes.AddRange(convertedNewLine);
        registeredBytes.AddRangeConversion(Converter, Assumption, "{");
        registeredBytes.AddRange(convertedNewLine);
        NewLine_BracketLeft_NewLine_Offset = accum;
        NewLine_BracketLeft_NewLine_Count = (uint)registeredBytes.Count - accum;
        accum = (uint)registeredBytes.Count;
<# foreach (var x in FormatterHelper.Pairs_NewLine) { #>

        registeredBytes.AddRangeConversion(Converter, Assumption, "<#= x.content #>");
        registeredBytes.AddRange(convertedNewLine);
        <#= x.name #>_NewLine_Offset = accum;
        <#= x.name #>_NewLine_Count = (uint)registeredBytes.Count - accum;
        accum = (uint)registeredBytes.Count;
<# } #>
<# foreach (var x in FormatterHelper.Pairs) { #>

        registeredBytes.AddRangeConversion(Converter, Assumption, "<#= x.content #>");
        <#= x.name #>_Offset = accum;
        <#= x.name #>_Count = (uint)registeredBytes.Count - accum;
        accum = (uint)registeredBytes.Count;
<# } #>
<# foreach (var x in FormatterHelper.Pairs_NewLine_Pairs) { #>

        registeredBytes.AddRangeConversion(Converter, Assumption, "<#= x.content0 #>");
        registeredBytes.AddRange(convertedNewLine);
        registeredBytes.AddRangeConversion(Converter, Assumption, "<#= x.content1 #>");
        <#= x.name0 #>_NewLine_<#= x.name1 #>_Offset = accum;
        <#= x.name0 #>_NewLine_<#= x.name1 #>_Count = (uint)registeredBytes.Count - accum;
        accum = (uint)registeredBytes.Count;
<# } #>
    }

    private void Append_NewLine(ref List<byte> destination, ref bool JustChangeLine)
    {
        JustChangeLine = true;
        destination.AddRange(registeredBytes.AsSpan(0, NewLineCount));
    }

    private void Ensure_NewLine_Indent(ref List<byte> destination, ref bool JustChangeLine, int indentCount)
    {
        if (!JustChangeLine)
        {
            destination.AddRange(registeredBytes.AsSpan(0, NewLineCount));
        }

        JustChangeLine = false;
        if (indentCount <= 0)
        {
            return;
        }

        var span = registeredBytes.AsSpan(TabOffset, TabCount);
        for (uint i = 0; i != indentCount; i++)
        {
            destination.AddRange(span);
        }
    }

    private void Append_Indent(ref List<byte> destination, ref bool JustChangeLine, int indentCount)
    {
        if (indentCount == 0)
        {
            return;
        }

        JustChangeLine = false;
        var span = registeredBytes.AsSpan(TabOffset, TabCount);
        for (uint i = 0; i != indentCount; i++)
        {
            destination.AddRange(span);
        }
    }

    private void Append_Copy(ref List<byte> destination, ref bool JustChangeLine, ReadOnlySpan<char> singleLineSource)
    {
        destination.AddRangeConversion(Converter, Assumption, singleLineSource);
    }

    private void Append_Copy(ref List<byte> destination, ref bool JustChangeLine, ref DualList<char> source, ref Range range)
    {
        ref var line = ref source[range.StartInclusive.Line];
        var slice = line.AsSpan(range.StartInclusive.Offset);
        if (range.StartInclusive.Line == range.EndExclusive.Line)
        {
            slice = slice.Slice(0, (int)(range.EndExclusive.Offset - range.StartInclusive.Offset));
            Append_Copy(ref destination, ref JustChangeLine, slice);
            return;
        }

        var lineIndex = range.StartInclusive.Line;
        do
        {
            Append_Copy(ref destination, ref JustChangeLine, slice);
            Append_NewLine(ref destination, ref JustChangeLine);
            if (++lineIndex != range.EndExclusive.Line)
            {
                slice = source[lineIndex].AsSpan();
                continue;
            }

            if (range.EndExclusive.Offset == 0)
            {
                return;
            }

            slice = source[lineIndex].AsSpan(0, range.EndExclusive.Offset);
            Append_Copy(ref destination, ref JustChangeLine, slice);
            return;
        } while (true);
    }

    private void Append_battle_NewLine_BracketLeft_NewLine(ref List<byte> destination, ref bool JustChangeLine)
    {
        JustChangeLine = true;
        destination.AddRange(registeredBytes.AsSpan(battle_NewLine_BracketLeft_NewLine_Offset, battle_NewLine_BracketLeft_NewLine_Count));
    }

    private void Append_NewLine_BracketLeft_NewLine(ref List<byte> destination, ref bool JustChangeLine)
    {
        JustChangeLine = true;
        destination.AddRange(registeredBytes.AsSpan(NewLine_BracketLeft_NewLine_Offset, NewLine_BracketLeft_NewLine_Count));
    }
<# foreach (var x in FormatterHelper.Pairs_NewLine) { #>

    private void Append_<#= x.name #>_NewLine(ref List<byte> destination, ref bool JustChangeLine)
    {
        JustChangeLine = true;
        destination.AddRange(registeredBytes.AsSpan(<#= x.name #>_NewLine_Offset, <#= x.name #>_NewLine_Count));
    }
<# } #>
<# foreach (var x in FormatterHelper.Pairs) { #>

    private void Append_<#= x.name #>(ref List<byte> destination, ref bool JustChangeLine)
    {
        JustChangeLine = false;
        destination.AddRange(registeredBytes.AsSpan(<#= x.name #>_Offset, <#= x.name #>_Count));
    }
<# } #>
<# foreach (var x in FormatterHelper.Pairs_NewLine_Pairs) { #>

    private void Append_<#= x.name0 #>_NewLine_<#= x.name1 #>(ref List<byte> destination, ref bool JustChangeLine)
    {
        JustChangeLine = false;
        destination.AddRange(registeredBytes.AsSpan(<#= x.name0 #>_NewLine_<#= x.name1 #>_Offset, <#= x.name0 #>_NewLine_<#= x.name1 #>_Count));
    }
<# } #>

    public bool TryFormat(ref Result result, ref List<byte> destination)
    {
        ref var TokenList = ref result.TokenList;
        ref var source = ref result.Source;
        bool JustChangeLine = false;
		for (uint tokenIndex = uint.MaxValue, tokenCount = (uint)TokenList.Count; ++tokenIndex < tokenCount;)
        {
            ref var token = ref TokenList[tokenIndex];
            switch (token.Kind)
            {
                case TokenKind.Comment:
                    if (tokenIndex > 0 && TokenList[tokenIndex - 1].Kind == TokenKind.BracketRight)
                    {
                        Append_NewLine(ref destination, ref JustChangeLine);
                    }

                    Append_Copy(ref destination, ref JustChangeLine, ref source, ref token.Range);
                    continue;
<# foreach (var item in FormatterHelper.NameNodes) { #>
                case TokenKind.<#= Helper.Escape(item) #>:
                    if (tokenIndex > 0 && TokenList[tokenIndex - 1].Kind != TokenKind.Comment)
                    {
                        Append_NewLine(ref destination, ref JustChangeLine);
                    }

                    Append_<#= item #>_Space(ref destination, ref JustChangeLine);
                    break;
<# } #>
<# foreach (var item in FormatterHelper.BlockNodes) { #>
                case TokenKind.<#= item #>:
                    if (tokenIndex > 0 && TokenList[tokenIndex - 1].Kind != TokenKind.Comment)
                    {
                        Append_NewLine(ref destination, ref JustChangeLine);
                    }

                    Append_<#= item #>_NewLine_BracketLeft(ref destination, ref JustChangeLine);
                    goto CONTENTS;
<# } #>
                default:
                    return false;
            }

            if (++tokenIndex + 1 >= TokenList.Count || TokenList[tokenIndex].Kind != TokenKind.Name)
            {
                return false;
            }

            Append_Copy(ref destination, ref JustChangeLine, result.GetSpan(tokenIndex));
            if (TokenList[++tokenIndex].Kind == TokenKind.Colon)
            {
                if (++tokenIndex + 1 >= TokenList.Count || TokenList[tokenIndex].Kind != TokenKind.Super)
                {
                    return false;
                }

                Append_Space_Colon_Space(ref destination, ref JustChangeLine);
                Append_Copy(ref destination, ref JustChangeLine, result.GetSpan(tokenIndex));
            }
            else
            {
                --tokenIndex;
            }

            Append_NewLine_BracketLeft_NewLine(ref destination, ref JustChangeLine);
        CONTENTS:
            if (++tokenIndex >= TokenList.Count || TokenList[tokenIndex].Kind != TokenKind.BracketLeft)
            {
                return false;
            }
            
            if (TryFormat_Block(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces: 1))
            {
                continue;
            }

            return false;
        }

        return true;
	}

    bool TryFormat_Block(ref List<Token> TokenList, ref DualList<char> source, ref List<byte> destination, ref bool JustChangeLine, ref uint tokenIndex, int spaces)
    {
        do
        {
            if (++tokenIndex >= TokenList.Count)
            {
                return false;
            }

            ref var token = ref TokenList[tokenIndex];
            switch (token.Kind)
            {
                case TokenKind.BracketRight:
                    Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces - 1);
                    Append_BracketRight_NewLine(ref destination, ref JustChangeLine);
                    return true;
                case TokenKind.Comment:
                    Append_Copy(ref destination, ref JustChangeLine, ref source, ref token.Range);
                    continue;
                case TokenKind.DEFAULT:
                    if (TryFormatElementAssignment_DEFAULT(ref TokenList, ref source, ref destination, ref JustChangeLine, ref token, ref tokenIndex, spaces))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.RAY:
                case TokenKind.CONSTI:
                case TokenKind.LOYAL:
                case TokenKind.MEMBER:
                case TokenKind.OFFSET:
                case TokenKind.ROAM:
                case TokenKind.TEXT:
                    if (TryFormatElementAssignment_Not_DEFAULT(ref TokenList, ref source, ref destination, ref JustChangeLine, ref token, ref tokenIndex, spaces))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.rif:
                    Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                    Append_rif_Space_ParenLeft(ref destination, ref JustChangeLine);
                    if (TryFormat_If(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.@if:
                    Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                    Append_if_Space_ParenLeft(ref destination, ref JustChangeLine);
                    if (TryFormat_If(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.@while:
                    Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                    Append_while_Space_ParenLeft(ref destination, ref JustChangeLine);
                    if (!TryFormat_Condition(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces))
                    {
                        return false;
                    }

                    if (!TryFormat_Block(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces))
                    {
                        return false;
                    }
                    continue;
                case TokenKind.battle:
                    Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                    Append_battle_NewLine_BracketLeft_NewLine(ref destination, ref JustChangeLine);
                    if (TryFormat_Block(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces))
                    {
                        continue;
                    }
                    return false;
<# foreach (var kind in new string[] { "break", "continue", "next", "return" }) { #>
                case TokenKind.<#= kind.Escape() #>:
                    Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                    Append_<#= kind #>_ParenLeft_ParenRight_NewLine(ref destination, ref JustChangeLine);
                    continue;
<# } #>
                case TokenKind.CallAction:
                    switch ((ActionKind)token.Other)
                    {
<# foreach (var (action, _, _) in ActionInfo.Normals) { #>
                        case ActionKind.<#= action.Escape() #>:
                            Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                            Append_<#= action #>_ParenLeft(ref destination, ref JustChangeLine);
                            break;
<# } #>
                        default:
                            Append_Copy(ref destination, ref JustChangeLine, ref source, ref token.Range);
                            break;
                    }

                    if (TryFormatCallActionArguments(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces))
                    {
                        continue;
                    }

                    return false;
            }
        } while (true);
    }

    bool TryFormatElementAssignment_Not_DEFAULT(ref List<Token> TokenList, ref DualList<char> source, ref List<byte> destination, ref bool JustChangeLine, ref Token element, ref uint tokenIndex, int spaces)
    {
        if (!TryFormatElementAssignment_DEFAULT(ref TokenList, ref source, ref destination, ref JustChangeLine, ref element, ref tokenIndex, spaces))
        {
            return false;
        }

        do
        {
            if (++tokenIndex >= TokenList.Count)
            {
                return false;
            }

            ref var token = ref TokenList[tokenIndex];
            switch (token.Kind)
            {
                case TokenKind.Content:
                    if (token.IsFirstTokenInTheLine)
                    {
                        Append_NewLine(ref destination, ref JustChangeLine);
                        Append_Indent(ref destination, ref JustChangeLine, spaces + 1);
                    }

                    Append_Copy(ref destination, ref JustChangeLine, ref source, ref token.Range);
                    continue;
                case TokenKind.Mul:
                    Append_Space_Mul_Space(ref destination, ref JustChangeLine);
                    continue;
                case TokenKind.Semicolon:
                    if (token.IsFirstTokenInTheLine)
                    {
                        Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                    }

                    Append_Semicolon(ref destination, ref JustChangeLine);
                    return true;
                case TokenKind.Comma:
                    if (tokenIndex + 1 < TokenList.Count && TokenList[tokenIndex + 1].IsFirstTokenInTheLine)
                    {
                        Append_Comma(ref destination, ref JustChangeLine);
                    }
                    else
                    {
                        Append_Comma_Space(ref destination, ref JustChangeLine);
                    }

                    continue;
                default:
                    --tokenIndex;
                    return true;
            }
        } while (true);
    }

    bool TryFormatElementAssignment_DEFAULT(ref List<Token> TokenList, ref DualList<char> source, ref List<byte> destination, ref bool JustChangeLine, ref Token element, ref uint tokenIndex, int spaces)
    {
        if (++tokenIndex + 1 >= TokenList.Count || TokenList[tokenIndex].Kind != TokenKind.Assign)
        {
            return false;
        }

        ref var content = ref TokenList[++tokenIndex];
        if (content.Kind != TokenKind.Content)
        {
            return false;
        }

        Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
        Append_Copy(ref destination, ref JustChangeLine, ref source, ref element.Range);
        if (content.IsFirstTokenInTheLine)
        {
            Append_Space_Assign(ref destination, ref JustChangeLine);
            Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces + 1);
        }
        else
        {
            Append_Space_Assign_Space(ref destination, ref JustChangeLine);
        }

        Append_Copy(ref destination, ref JustChangeLine, ref source, ref content.Range);
        return true;
    }

    bool TryFormatCallActionArguments(ref List<Token> TokenList, ref DualList<char> source, ref List<byte> destination, ref bool JustChangeLine, ref uint tokenIndex, int spaces)
    {
        do
        {
            if (++tokenIndex >= TokenList.Count)
            {
                return false;
            }

            ref var token = ref TokenList[tokenIndex];
            switch (token.Kind)
            {
                case TokenKind.Content:
                    if (token.IsFirstTokenInTheLine)
                    {
                        Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces + 1);
                    }
                    Append_Copy(ref destination, ref JustChangeLine, ref source, ref token.Range);
                    continue;
                case TokenKind.Comma:
                    if (tokenIndex + 1 < TokenList.Count && TokenList[tokenIndex + 1].IsFirstTokenInTheLine)
                    {
                        Append_Comma(ref destination, ref JustChangeLine);
                    }
                    else
                    {
                        Append_Comma_Space(ref destination, ref JustChangeLine);
                    }

                    continue;
                case TokenKind.ParenRight:
                    Append_ParenRight(ref destination, ref JustChangeLine);
                    return true;
                default:
                    --tokenIndex;
                    return true;
            }
        } while (true);
    }

    bool TryFormat_If(ref List<Token> TokenList, ref DualList<char> source, ref List<byte> destination, ref bool JustChangeLine, ref uint tokenIndex, int spaces)
    {
        if (!TryFormat_Condition(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces))
        {
            return false;
        }

        if (!TryFormat_Block(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces + 1))
        {
            return false;
        }

        if (++tokenIndex + 1 >= TokenList.Count || TokenList[tokenIndex].Kind != TokenKind.Else)
        {
            --tokenIndex;
            return true;
        }

        Append_Indent(ref destination, ref JustChangeLine, spaces);
        switch (TokenList[++tokenIndex].Kind)
        {
            case TokenKind.@if:
                Append_else_Space_if_ParenLeft(ref destination, ref JustChangeLine);
                return TryFormat_If(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces);
            case TokenKind.rif:
                Append_else_Space_rif_ParenLeft(ref destination, ref JustChangeLine);
                return TryFormat_If(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces);
            case TokenKind.BracketLeft:
                Append_else_NewLine(ref destination, ref JustChangeLine);
                Append_Indent(ref destination, ref JustChangeLine, spaces);
                Append_BracketLeft_NewLine(ref destination, ref JustChangeLine);
                return TryFormat_Block(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces + 1);
            default:
                return false;
        }
    }

    bool TryFormat_Condition(ref List<Token> TokenList, ref DualList<char> source, ref List<byte> destination, ref bool JustChangeLine, ref uint tokenIndex, int spaces)
    {
        do
        {
            if (++tokenIndex >= TokenList.Count)
            {
                return false;
            }

            ref var token = ref TokenList[tokenIndex];
            switch (token.Kind)
            {
                case TokenKind.BracketLeft:
                    Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                    Append_BracketLeft(ref destination, ref JustChangeLine);
                    return true;
<# foreach (var x in FormatterHelper.Operators) { #>
                case TokenKind.<#= x.name #>:
                    Append_Space_<#= x.name #>_Space(ref destination, ref JustChangeLine);
                    continue;
<# }#>
                case TokenKind.ParenLeft:
                    Append_ParenLeft(ref destination, ref JustChangeLine);
                    continue;
                case TokenKind.ParenRight:
                    Append_ParenRight(ref destination, ref JustChangeLine);
                    continue;
                case TokenKind.Comma:
                    Append_Comma_Space(ref destination, ref JustChangeLine);
                    continue;
                case TokenKind.CallFunction:
                    switch ((FunctionKind)token.Other)
                    {
<# foreach (var (name, _, _) in FunctionInfo.FunctionInfoArray) { #>
                        case FunctionKind.<#= name.Escape() #>:
                            Append_<#= name #>_ParenLeft(ref destination, ref JustChangeLine);
                            continue;
<# } #>
                    }

                    goto default;
                default:
                    Append_Copy(ref destination, ref JustChangeLine, ref source, ref token.Range);
                    continue;
            }
        } while (true);
    }
}
