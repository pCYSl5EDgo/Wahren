<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.TextTemplateHelper.dll" #>
<#@ import namespace="Wahren.AbstractSyntaxTree.TextTemplateHelper" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#nullable enable
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using Wahren.AbstractSyntaxTree.Parser;

namespace Wahren.AbstractSyntaxTree.Formatter;

public class BinaryFormatter : IFormatter<byte>
{
    static BinaryFormatter()
    {
        System.Text.Encoding.RegisterProvider(System.Text.CodePagesEncodingProvider.Instance);
    }

    private static BinaryFormatter? _Default_Utf16Le_CrLf;
    private static BinaryFormatter? _Default_Utf16Le_Lf;
    private static BinaryFormatter? _Default_Cp932_CrLf;
    private static BinaryFormatter? _Default_Cp932_Lf;

    public static BinaryFormatter GetDefault_Utf16Le(bool isCrLf)
    {
        if (isCrLf)
        {
            return _Default_Utf16Le_CrLf ??= new(System.Text.Encoding.Unicode, ' ', 4, "\r\n");
        }
        else
        {
            return _Default_Utf16Le_Lf ??= new(System.Text.Encoding.Unicode, ' ', 4, "\n");
        }
    }

    public static BinaryFormatter GetDefault_Cp932(bool isCrLf)
    {
        if (isCrLf)
        {
            return _Default_Cp932_CrLf ??= new(System.Text.Encoding.GetEncoding(932), ' ', 4, "\r\n");
        }
        else
        {
            return _Default_Cp932_Lf ??= new(System.Text.Encoding.GetEncoding(932), ' ', 4, "\n");
        }
    }

    private readonly byte[] registeredBytes;
    private readonly List<byte>.AddConverter<char> Converter;
    private readonly List<byte>.AddConverterAssumption Assumption;

    private readonly int NewLine_Offset;
    private readonly int NewLine_Count;
    private const int Indent_Offset = 0;
    private readonly int Indent_Count;

<# foreach (var x in FormatterHelper.Pairs_NewLine) { #>
    private readonly int <#= x.name #>_NewLine_Offset;
    private readonly int <#= x.name #>_NewLine_Count;
<# } #>
<# foreach (var x in FormatterHelper.Pairs) { #>
    private readonly int <#= x.name #>_Offset;
    private readonly int <#= x.name #>_Count;
<# } #>
<# foreach (var x in FormatterHelper.Pairs_NewLine_Pairs) { #>
    private readonly int <#= x.name0 #>_NewLine_<#= x.name1 #>_Offset;
    private readonly int <#= x.name0 #>_NewLine_<#= x.name1 #>_Count;
<# } #>
    private readonly int NewLine_BracketLeft_NewLine_Offset;
    private readonly int NewLine_BracketLeft_NewLine_Count;

    public BinaryFormatter(System.Text.Encoding encoding, char indentChar, int indentCount, ReadOnlySpan<char> newLine) : this(new(encoding.GetBytes), new(encoding.GetMaxByteCount), indentChar, indentCount, newLine) {}
    public BinaryFormatter(List<byte>.AddConverter<char> converter, List<byte>.AddConverterAssumption assumption, char indentChar, int indentCount, ReadOnlySpan<char> newLine)
    {
        Converter = converter;
        Assumption = assumption;
        
        Span<byte> spanNewLine = stackalloc byte[Assumption(newLine.Length)];
        NewLine_Count = Converter(newLine, spanNewLine);
        spanNewLine = spanNewLine.Slice(0, NewLine_Count);
        
        Span<char> spanIndentSource = stackalloc char[indentCount];
        Span<byte> spanIndent = stackalloc byte[Assumption(indentCount)];
        spanIndentSource.Fill(indentChar);
        Indent_Count = Converter(spanIndentSource, spanIndent);
        spanIndent = spanIndent.Slice(0, Indent_Count);

<# int total = 0;
foreach (var x in FormatterHelper.Pairs) { total += x.content.Length; }
foreach (var x in FormatterHelper.Pairs_NewLine) { total += x.content.Length; }
foreach (var x in FormatterHelper.Pairs_NewLine_Pairs) { total += x.content0.Length + x.content1.Length; }
#>
        registeredBytes = GC.AllocateUninitializedArray<byte>(Assumption(<#= total + 1 #>) + NewLine_Count * <#= 2 + FormatterHelper.Pairs_NewLine.Length + FormatterHelper.Pairs_NewLine_Pairs.Length #> + Indent_Count, true);

        spanIndent.CopyTo(registeredBytes.AsSpan(0, Indent_Count));
        int accum = Indent_Count;

        NewLine_Offset = accum;
        NewLine_BracketLeft_NewLine_Offset = accum;
        spanNewLine.CopyTo(registeredBytes.AsSpan(accum, NewLine_Count));
        accum += NewLine_Count;
        accum += Converter("{", registeredBytes.AsSpan(accum));
        spanNewLine.CopyTo(registeredBytes.AsSpan(accum, NewLine_Count));
        accum += NewLine_Count;
        NewLine_BracketLeft_NewLine_Count = accum - NewLine_BracketLeft_NewLine_Offset;

<# foreach (var x in FormatterHelper.Pairs_NewLine) { #>

        <#= x.name #>_NewLine_Offset = accum;
        accum += Converter("<#= x.content #>", registeredBytes.AsSpan(accum));
        spanNewLine.CopyTo(registeredBytes.AsSpan(accum, NewLine_Count));
        accum += NewLine_Count;
        <#= x.name #>_NewLine_Count = accum - <#= x.name #>_NewLine_Offset;
<# } #>
<# foreach (var x in FormatterHelper.Pairs) { #>

        <#= x.name #>_Offset = accum;
        <#= x.name #>_Count = Converter("<#= x.content #>", registeredBytes.AsSpan(accum));
        accum += <#= x.name #>_Count;
<# } #>
<# foreach (var x in FormatterHelper.Pairs_NewLine_Pairs) { #>

        <#= x.name0 #>_NewLine_<#= x.name1 #>_Offset = accum;
        accum += Converter("<#= x.content0 #>", registeredBytes.AsSpan(accum));
        spanNewLine.CopyTo(registeredBytes.AsSpan(accum, NewLine_Count));
        accum += NewLine_Count;
        accum += Converter("<#= x.content1 #>", registeredBytes.AsSpan(accum));
        <#= x.name0 #>_NewLine_<#= x.name1 #>_Count = accum - <#= x.name0 #>_NewLine_<#= x.name1 #>_Offset;
<# } #>
    }

    private void Append_NewLine(ref List<byte> destination, ref bool JustChangeLine)
    {
        JustChangeLine = true;
        destination.AddRange(registeredBytes.AsSpan(NewLine_Offset, NewLine_Count));
    }

    private void Ensure_NewLine_Indent(ref List<byte> destination, ref bool JustChangeLine, int indentCount)
    {
        if (!JustChangeLine)
        {
            destination.AddRange(registeredBytes.AsSpan(NewLine_Offset, NewLine_Count));
        }

        JustChangeLine = false;
        if (indentCount <= 0)
        {
            return;
        }

        var span = registeredBytes.AsSpan(Indent_Offset, Indent_Count);
        for (uint i = 0; i != indentCount; i++)
        {
            destination.AddRange(span);
        }
    }

    private void Append_Indent(ref List<byte> destination, ref bool JustChangeLine, int indentCount)
    {
        if (indentCount == 0)
        {
            return;
        }

        JustChangeLine = false;
        var span = registeredBytes.AsSpan(Indent_Offset, Indent_Count);
        for (uint i = 0; i != indentCount; i++)
        {
            destination.AddRange(span);
        }
    }

    private void Append_Copy(ref List<byte> destination, ref bool JustChangeLine, ReadOnlySpan<char> singleLineSource)
    {
        destination.AddRangeConversion(Converter, Assumption, singleLineSource);
    }

    private void Append_Copy(ref List<byte> destination, ref bool JustChangeLine, ref DualList<char> source, ref Range range)
    {
        ref var line = ref source[range.StartInclusive.Line];
        var slice = line.AsSpan(range.StartInclusive.Offset);
        if (range.StartInclusive.Line == range.EndExclusive.Line)
        {
            slice = slice.Slice(0, (int)(range.EndExclusive.Offset - range.StartInclusive.Offset));
            Append_Copy(ref destination, ref JustChangeLine, slice);
            return;
        }

        var lineIndex = range.StartInclusive.Line;
        do
        {
            Append_Copy(ref destination, ref JustChangeLine, slice);
            Append_NewLine(ref destination, ref JustChangeLine);
            if (++lineIndex != range.EndExclusive.Line)
            {
                slice = source[lineIndex].AsSpan();
                continue;
            }

            if (range.EndExclusive.Offset == 0)
            {
                return;
            }

            slice = source[lineIndex].AsSpan(0, range.EndExclusive.Offset);
            Append_Copy(ref destination, ref JustChangeLine, slice);
            return;
        } while (true);
    }

    private void Append_NewLine_BracketLeft_NewLine(ref List<byte> destination, ref bool JustChangeLine)
    {
        JustChangeLine = true;
        destination.AddRange(registeredBytes.AsSpan(NewLine_BracketLeft_NewLine_Offset, NewLine_BracketLeft_NewLine_Count));
    }

<# foreach (var x in FormatterHelper.Pairs_NewLine) { #>

    private void Append_<#= x.name #>_NewLine(ref List<byte> destination, ref bool JustChangeLine)
    {
        JustChangeLine = true;
        destination.AddRange(registeredBytes.AsSpan(<#= x.name #>_NewLine_Offset, <#= x.name #>_NewLine_Count));
    }
<# } #>
<# foreach (var x in FormatterHelper.Pairs) { #>

    private void Append_<#= x.name #>(ref List<byte> destination, ref bool JustChangeLine)
    {
        JustChangeLine = false;
        destination.AddRange(registeredBytes.AsSpan(<#= x.name #>_Offset, <#= x.name #>_Count));
    }
<# } #>
<# foreach (var x in FormatterHelper.Pairs_NewLine_Pairs) { #>

    private void Append_<#= x.name0 #>_NewLine_<#= x.name1 #>(ref List<byte> destination, ref bool JustChangeLine)
    {
        JustChangeLine = false;
        destination.AddRange(registeredBytes.AsSpan(<#= x.name0 #>_NewLine_<#= x.name1 #>_Offset, <#= x.name0 #>_NewLine_<#= x.name1 #>_Count));
    }
<# } #>

    public bool TryFormat(ref Result result, ref List<byte> destination)
    {
        ref var TokenList = ref result.TokenList;
        ref var source = ref result.Source;
        bool JustChangeLine = false;
		for (uint tokenIndex = uint.MaxValue, tokenCount = (uint)TokenList.Count; ++tokenIndex < tokenCount;)
        {
            ref var token = ref TokenList[tokenIndex];
            switch (token.Kind)
            {
                case TokenKind.Comment:
                    if (tokenIndex > 0 && TokenList[tokenIndex - 1].Kind == TokenKind.BracketRight)
                    {
                        Append_NewLine(ref destination, ref JustChangeLine);
                    }

                    Append_Copy(ref destination, ref JustChangeLine, ref source, ref token.Range);
                    continue;
<# foreach (var item in FormatterHelper.NameNodes) { #>
                case TokenKind.<#= Helper.Escape(item) #>:
                    if (tokenIndex > 0 && TokenList[tokenIndex - 1].Kind != TokenKind.Comment)
                    {
                        Append_NewLine(ref destination, ref JustChangeLine);
                    }

                    Append_<#= item #>_Space(ref destination, ref JustChangeLine);
                    break;
<# } #>
<# foreach (var item in FormatterHelper.BlockNodes) { #>
                case TokenKind.<#= item #>:
                    if (tokenIndex > 0 && TokenList[tokenIndex - 1].Kind != TokenKind.Comment)
                    {
                        Append_NewLine(ref destination, ref JustChangeLine);
                    }

                    Append_<#= item #>_NewLine_BracketLeft(ref destination, ref JustChangeLine);
                    goto CONTENTS;
<# } #>
                default:
                    return false;
            }

            if (++tokenIndex + 1 >= TokenList.Count || TokenList[tokenIndex].Kind != TokenKind.Name)
            {
                return false;
            }

            Append_Copy(ref destination, ref JustChangeLine, result.GetSpan(tokenIndex));
            if (TokenList[++tokenIndex].Kind == TokenKind.Colon)
            {
                if (++tokenIndex + 1 >= TokenList.Count || TokenList[tokenIndex].Kind != TokenKind.Super)
                {
                    return false;
                }

                Append_Space_Colon_Space(ref destination, ref JustChangeLine);
                Append_Copy(ref destination, ref JustChangeLine, result.GetSpan(tokenIndex));
            }
            else
            {
                --tokenIndex;
            }

            Append_NewLine_BracketLeft_NewLine(ref destination, ref JustChangeLine);
        CONTENTS:
            if (++tokenIndex >= TokenList.Count || TokenList[tokenIndex].Kind != TokenKind.BracketLeft)
            {
                return false;
            }
            
            if (TryFormat_Block(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces: 1))
            {
                continue;
            }

            return false;
        }

        return true;
	}

    bool TryFormat_Block(ref List<Token> TokenList, ref DualList<char> source, ref List<byte> destination, ref bool JustChangeLine, ref uint tokenIndex, int spaces)
    {
        do
        {
            if (++tokenIndex >= TokenList.Count)
            {
                return false;
            }

            ref var token = ref TokenList[tokenIndex];
            switch (token.Kind)
            {
                case TokenKind.BracketRight:
                    Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces - 1);
                    Append_BracketRight_NewLine(ref destination, ref JustChangeLine);
                    return true;
                case TokenKind.Comment:
                    Append_Copy(ref destination, ref JustChangeLine, ref source, ref token.Range);
                    continue;
                case TokenKind.DEFAULT:
                    if (TryFormatElementAssignment_DEFAULT(ref TokenList, ref source, ref destination, ref JustChangeLine, ref token, ref tokenIndex, spaces))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.RAY:
                case TokenKind.CONSTI:
                case TokenKind.LOYAL:
                case TokenKind.MEMBER:
                case TokenKind.OFFSET:
                case TokenKind.ROAM:
                case TokenKind.TEXT:
                    if (TryFormatElementAssignment_Not_DEFAULT(ref TokenList, ref source, ref destination, ref JustChangeLine, ref token, ref tokenIndex, spaces))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.rif:
                    Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                    Append_rif_Space_ParenLeft(ref destination, ref JustChangeLine);
                    if (TryFormat_If(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.@if:
                    Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                    Append_if_Space_ParenLeft(ref destination, ref JustChangeLine);
                    if (TryFormat_If(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces))
                    {
                        continue;
                    }

                    return false;
                case TokenKind.@while:
                    Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                    Append_while_Space_ParenLeft(ref destination, ref JustChangeLine);
                    if (!TryFormat_Condition(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces))
                    {
                        return false;
                    }

                    if (!TryFormat_Block(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces))
                    {
                        return false;
                    }
                    continue;
                case TokenKind.battle:
                    Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                    Append_battle_NewLine(ref destination, ref JustChangeLine);
                    Append_Indent(ref destination, ref JustChangeLine, spaces);
                    Append_BracketLeft_NewLine(ref destination, ref JustChangeLine);
                    if (TryFormat_Block(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces))
                    {
                        continue;
                    }
                    return false;
<# foreach (var kind in new string[] { "break", "continue", "next", "return" }) { #>
                case TokenKind.<#= kind.Escape() #>:
                    Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                    Append_<#= kind #>_ParenLeft_ParenRight_NewLine(ref destination, ref JustChangeLine);
                    continue;
<# } #>
                case TokenKind.CallAction:
                    switch ((ActionKind)token.Other)
                    {
<# foreach (var (action, _, _) in CallableInfo.ActionInfoNormals) { #>
                        case ActionKind.<#= action.Escape() #>:
                            Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                            Append_<#= action #>_ParenLeft(ref destination, ref JustChangeLine);
                            break;
<# } #>
                        default:
                            Append_Copy(ref destination, ref JustChangeLine, ref source, ref token.Range);
                            break;
                    }

                    if (TryFormatCallActionArguments(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces))
                    {
                        continue;
                    }

                    return false;
            }
        } while (true);
    }

    bool TryFormatElementAssignment_Not_DEFAULT(ref List<Token> TokenList, ref DualList<char> source, ref List<byte> destination, ref bool JustChangeLine, ref Token element, ref uint tokenIndex, int spaces)
    {
        if (!TryFormatElementAssignment_DEFAULT(ref TokenList, ref source, ref destination, ref JustChangeLine, ref element, ref tokenIndex, spaces))
        {
            return false;
        }

        do
        {
            if (++tokenIndex >= TokenList.Count)
            {
                return false;
            }

            ref var token = ref TokenList[tokenIndex];
            switch (token.Kind)
            {
                case TokenKind.Content:
                    if (token.IsFirstTokenInTheLine)
                    {
                        Append_NewLine(ref destination, ref JustChangeLine);
                        Append_Indent(ref destination, ref JustChangeLine, spaces + 1);
                    }

                    Append_Copy(ref destination, ref JustChangeLine, ref source, ref token.Range);
                    continue;
                case TokenKind.Mul:
                    Append_Space_Mul_Space(ref destination, ref JustChangeLine);
                    continue;
                case TokenKind.Semicolon:
                    if (token.IsFirstTokenInTheLine)
                    {
                        Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                    }

                    Append_Semicolon(ref destination, ref JustChangeLine);
                    return true;
                case TokenKind.Comma:
                    if (tokenIndex + 1 < TokenList.Count && TokenList[tokenIndex + 1].IsFirstTokenInTheLine)
                    {
                        Append_Comma(ref destination, ref JustChangeLine);
                    }
                    else
                    {
                        Append_Comma_Space(ref destination, ref JustChangeLine);
                    }

                    continue;
                default:
                    --tokenIndex;
                    return true;
            }
        } while (true);
    }

    bool TryFormatElementAssignment_DEFAULT(ref List<Token> TokenList, ref DualList<char> source, ref List<byte> destination, ref bool JustChangeLine, ref Token element, ref uint tokenIndex, int spaces)
    {
        if (++tokenIndex + 1 >= TokenList.Count || TokenList[tokenIndex].Kind != TokenKind.Assign)
        {
            return false;
        }

        ref var content = ref TokenList[++tokenIndex];
        if (content.Kind != TokenKind.Content)
        {
            return false;
        }

        Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
        Append_Copy(ref destination, ref JustChangeLine, ref source, ref element.Range);
        if (content.IsFirstTokenInTheLine)
        {
            Append_Space_Assign(ref destination, ref JustChangeLine);
            Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces + 1);
        }
        else
        {
            Append_Space_Assign_Space(ref destination, ref JustChangeLine);
        }

        Append_Copy(ref destination, ref JustChangeLine, ref source, ref content.Range);
        return true;
    }

    bool TryFormatCallActionArguments(ref List<Token> TokenList, ref DualList<char> source, ref List<byte> destination, ref bool JustChangeLine, ref uint tokenIndex, int spaces)
    {
        do
        {
            if (++tokenIndex >= TokenList.Count)
            {
                return false;
            }

            ref var token = ref TokenList[tokenIndex];
            switch (token.Kind)
            {
                case TokenKind.Content:
                    if (token.IsFirstTokenInTheLine)
                    {
                        Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces + 1);
                    }
                    Append_Copy(ref destination, ref JustChangeLine, ref source, ref token.Range);
                    continue;
                case TokenKind.Comma:
                    if (tokenIndex + 1 < TokenList.Count && TokenList[tokenIndex + 1].IsFirstTokenInTheLine)
                    {
                        Append_Comma(ref destination, ref JustChangeLine);
                    }
                    else
                    {
                        Append_Comma_Space(ref destination, ref JustChangeLine);
                    }

                    continue;
                case TokenKind.ParenRight:
                    Append_ParenRight(ref destination, ref JustChangeLine);
                    return true;
                default:
                    --tokenIndex;
                    return true;
            }
        } while (true);
    }

    bool TryFormat_If(ref List<Token> TokenList, ref DualList<char> source, ref List<byte> destination, ref bool JustChangeLine, ref uint tokenIndex, int spaces)
    {
        if (!TryFormat_Condition(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces))
        {
            return false;
        }

        if (!TryFormat_Block(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces + 1))
        {
            return false;
        }

        if (++tokenIndex + 1 >= TokenList.Count || TokenList[tokenIndex].Kind != TokenKind.Else)
        {
            --tokenIndex;
            return true;
        }

        Append_Indent(ref destination, ref JustChangeLine, spaces);
        switch (TokenList[++tokenIndex].Kind)
        {
            case TokenKind.@if:
                Append_else_Space_if_ParenLeft(ref destination, ref JustChangeLine);
                return TryFormat_If(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces);
            case TokenKind.rif:
                Append_else_Space_rif_ParenLeft(ref destination, ref JustChangeLine);
                return TryFormat_If(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces);
            case TokenKind.BracketLeft:
                Append_else_NewLine(ref destination, ref JustChangeLine);
                Append_Indent(ref destination, ref JustChangeLine, spaces);
                Append_BracketLeft_NewLine(ref destination, ref JustChangeLine);
                return TryFormat_Block(ref TokenList, ref source, ref destination, ref JustChangeLine, ref tokenIndex, spaces + 1);
            default:
                return false;
        }
    }

    bool TryFormat_Condition(ref List<Token> TokenList, ref DualList<char> source, ref List<byte> destination, ref bool JustChangeLine, ref uint tokenIndex, int spaces)
    {
        do
        {
            if (++tokenIndex >= TokenList.Count)
            {
                return false;
            }

            ref var token = ref TokenList[tokenIndex];
            switch (token.Kind)
            {
                case TokenKind.BracketLeft:
                    Ensure_NewLine_Indent(ref destination, ref JustChangeLine, spaces);
                    Append_BracketLeft(ref destination, ref JustChangeLine);
                    return true;
<# foreach (var x in FormatterHelper.Operators) { #>
                case TokenKind.<#= x.name #>:
                    Append_Space_<#= x.name #>_Space(ref destination, ref JustChangeLine);
                    continue;
<# }#>
                case TokenKind.ParenLeft:
                    Append_ParenLeft(ref destination, ref JustChangeLine);
                    continue;
                case TokenKind.ParenRight:
                    Append_ParenRight(ref destination, ref JustChangeLine);
                    continue;
                case TokenKind.Comma:
                    Append_Comma_Space(ref destination, ref JustChangeLine);
                    continue;
                case TokenKind.CallFunction:
                    switch ((FunctionKind)token.Other)
                    {
<# foreach (var (name, _, _) in CallableInfo.FunctionInfoNormals) { #>
                        case FunctionKind.<#= name.Escape() #>:
                            Append_<#= name #>_ParenLeft(ref destination, ref JustChangeLine);
                            continue;
<# } #>
                    }

                    goto default;
                default:
                    Append_Copy(ref destination, ref JustChangeLine, ref source, ref token.Range);
                    continue;
            }
        } while (true);
    }
}
