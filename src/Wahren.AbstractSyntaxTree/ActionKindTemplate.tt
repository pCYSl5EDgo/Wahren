<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.TextTemplateHelper.dll" #>
<#@ import namespace="Wahren.AbstractSyntaxTree.TextTemplateHelper" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#nullable enable
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
namespace Wahren.AbstractSyntaxTree;

public enum ActionKind : uint
{
<# foreach (var item in ActionInfo.Specials) { #>
	<#= item.Escape() #>,
<# } #>
<#
foreach (var item in ActionInfo.Normals) { #>
	<#= item.Name.Escape() #>,
<# } #>
	None = uint.MaxValue
}

public static class ActionKindHelper
{
	public static ActionKind Convert(ReadOnlySpan<char> key)
	{
		if (key.Length < 2 || key.Length > 20)
		{
			return ActionKind.None;
		}

		Span<char> span = stackalloc char[key.Length < 4 ? 4 : key.Length];
        key.CopyTo(span);
		span.Slice(key.Length).Clear();
        for (var i = 0; i < key.Length; ++i)
        {
            if (span[i] >= 'a')
            {
                span[i] = (char)(ushort)(span[i] - 32);
            }
        }

        ulong key4 = System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian(System.Runtime.InteropServices.MemoryMarshal.Cast<char, byte>(span));
        span = span.Slice(4);
		switch (span.Length)
        {
<#
foreach (var item in ActionInfo.Specials.Concat(ActionInfo.Normals.Select(x => x.Name)))
{
	var x = item.Escape();
	ulong key = 0UL;
	if (item.Length >= 4)
	{
		key |= (ulong)(uint)item[3] - 32UL * (ulong)((ushort)item[3] >= (ushort)'a' ? 1: 0);
		key <<= 16;
	}
    
	if (item.Length >= 3)
	{
		key |= (ulong)(uint)item[2] - 32UL * (ulong)((ushort)item[2] >= (ushort)'a' ? 1: 0);
		key <<= 16;
	}
    
    key |= (ulong)(uint)item[1] - 32UL * (ulong)((ushort)item[1] >= (ushort)'a' ? 1: 0);
    key <<= 16;
    key |= (ulong)(uint)item[0] - 32UL * (ulong)((ushort)item[0] >= (ushort)'a' ? 1: 0);
	var keyStr = "0x" + key.ToString("X16");
	Func<int, char> pf = (int index) => {
		return (char)(ushort)(item[index] -32 * (item[index] >= 'a' ? 1 : 0));		
	};
	if (item.Length <= 4)
	{
#>
			case 0 when key4 == <#= keyStr #>UL: return ActionKind.<#= x #>;
<#
	}
	else if (item.Length == 5)
	{
#>
			case 1 when (key4 == <#= keyStr #>UL) && (span[0] == '<#= pf(4) #>'): return ActionKind.<#= x #>;
<#
	}
	else
	{
#>
			case <#= item.Length - 4 #> when (key4 == <#= keyStr #>UL) && span.SequenceEqual("<#for(int i = 4; i < item.Length; ++i){#><#= pf(i) #><# } #>"): return ActionKind.<#= x #>;
<#
	}
}
#>
		}

		return ActionKind.None;
	}

	public static int IsValidArgumentCount(this ActionKind kind, int count)
    {
        if (count < 0)
        {
            return -1;
        }

		switch (kind)
        {
<#
foreach ((int min, IEnumerable<(int, IEnumerable<string>)> groupEnumerable) in ActionInfo.Normals.GroupBy(
    item => item.Min,
    item => (item.Name, item.Max),
    (key, values) => (
        key,
        values.GroupBy(
            pair => pair.Max,
            pair => pair.Name,
            (keyInner, valuesInner) => (keyInner, valuesInner)
        )
    )))
{
    foreach (var (max, items) in groupEnumerable)
    {
        if (min == 0 && max == int.MaxValue) continue;
        var itemArray = items.ToArray();
        for (var index = 0; index < itemArray.Length; ++index) {
#>
            case ActionKind.<#= itemArray[index].Escape() #>:
<#
        }

                var item = itemArray[itemArray.Length - 1]; #>
<#      if (min == max && min == 0) { #>
                return count != <#= min #> ? 1 : 0;
<#      } else if (min == max) { #>
                return count != <#= min #> ? (1 - ((count < <#= min #> ? 1 : 0) << 1)) : 0;
<#      } else if (max == int.MaxValue) { #>
                return -(count < <#= min #> ? 1 : 0);
<#      } else if (min == 0) { #>
                return count > <#= max #> ? 1 : 0;
<#      } else { #>
                return count >= <#= min #> ? (count > <#= max #> ? 1 : 0) : -1;
<#      }
    }
}
#>
            default: return 0;
        }
	}
}
