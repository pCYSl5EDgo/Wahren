<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Memory" #>
<#@ assembly name="NetStandard" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.TextTemplateHelper.dll" #>
<#@ assembly name="$(t4LibFolder)\Wahren.AbstractSyntaxTree.Basic.dll" #>
<#@ import namespace="Wahren.AbstractSyntaxTree.TextTemplateHelper" #>
<#@ import namespace="Wahren.AbstractSyntaxTree" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
#nullable enable
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
namespace Wahren.AbstractSyntaxTree.Node;

public sealed class ContextNode : INode
{
    public uint Kind { get; set; }
    public uint BracketLeft { get; set; }
    public uint BracketRight { get; set; }

<# foreach (var context in ElementInfo.Context.GroupBy(x => x.Name.Length, x => x, (leng, xs) => (leng, xs.OrderBy(x => x.Name, StringComparer.Ordinal))).SelectMany(x => { var (len, enumerable)= x; return enumerable; })) { #>
    public Pair_NullableString_NullableInt_ArrayElement? <#= context.Name.Escape() #>;
<# } #>
    public void Dispose()
    {
<# foreach (var context in ElementInfo.Context.GroupBy(x => x.Name.Length, x => x, (leng, xs) => (leng, xs.OrderBy(x => x.Name, StringComparer.Ordinal))).SelectMany(x => { var (len, enumerable)= x; return enumerable; })) { #>
        <#= context.Name.Escape() #>?.Dispose();
        <#= context.Name.Escape() #> = null;
<# } #>
    }

    public ref Pair_NullableString_NullableInt_ArrayElement? TryGet(ReadOnlySpan<char> key)
    {
        if (key.Length < 4)
        {
            goto FALSE;
        }

        var keyULong = StringHashUtility.Calc(key);
        switch (key.Length)
        {
<# foreach (var (len, t) in ElementInfo.Context.GroupBy(x => x.Name.Length, x => x, (leng, xs) => (leng, xs.OrderBy(x => x.Name, StringComparer.Ordinal)))) { #>
            case <#= len #>:
                switch (keyULong)
                {
<#  foreach (var item in t) { #>
<# if (len > StringHashUtility.HashLengthMax + 1) {#>
                    case 0x<#= item.Name.GetKey().ToString("X16") #>UL when key.Slice(StringHashUtility.HashLengthMax).SequenceEqual("<#= item.Name.Substring(StringHashUtility.HashLengthMax) #>"):
<# } else if (len == StringHashUtility.HashLengthMax + 1) { #>
                    case 0x<#= item.Name.GetKey().ToString("X16") #>UL when key[StringHashUtility.HashLengthMax] == '<#= item.Name[StringHashUtility.HashLengthMax] #>':
<# } else { #>
                    case 0x<#= item.Name.GetKey().ToString("X16") #>UL:
<# } #>
                        return ref <#= item.Name.Escape() #>;
<#  } #>
                }
                break;
<# } #>
        }

    FALSE:
        return ref Unsafe.NullRef<Pair_NullableString_NullableInt_ArrayElement?>();
    }
<# foreach (var (prefix, op) in new[] { ("In", "+"), ("De", "-") }) { #>

    public void <#= prefix #>crementToken(uint indexEqualToOrGreaterThan, uint count)
    {
        if (Kind >= indexEqualToOrGreaterThan)
        {
            Kind <#= op #>= count;
        }

        if (BracketLeft >= indexEqualToOrGreaterThan)
        {
            BracketLeft <#= op #>= count;
        }

        if (BracketRight >= indexEqualToOrGreaterThan)
        {
            BracketRight <#= op #>= count;
        }
<# foreach (var context in ElementInfo.Context.GroupBy(x => x.Name.Length, x => x, (leng, xs) => (leng, xs.OrderBy(x => x.Name, StringComparer.Ordinal))).SelectMany(x => { var (len, enumerable)= x; return enumerable; })) { #>
        <#= context.Name.Escape() #>?.<#= prefix #>crementToken(indexEqualToOrGreaterThan, count);
<#  } #>
    }
<# } #>
}
